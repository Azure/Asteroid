define(["require", "exports", "tslib", "react", "@griffel/react", "@fluentui/react-context-selector", "../TabList/TabListContext", "@fluentui/react-theme"], function (require, exports, tslib_1, React, react_1, react_context_selector_1, TabListContext_1, react_theme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTabAnimatedIndicatorStyles_unstable = void 0;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var tabIndicatorCssVars_unstable = {
        offsetVar: '--fui-Tab__indicator--offset',
        scaleVar: '--fui-Tab__indicator--scale',
    };
    var useActiveIndicatorStyles = react_1.makeStyles({
        base: tslib_1.__assign({}, react_1.shorthands.overflow('visible')),
        animated: {
            '::after': {
                transitionProperty: 'transform',
                transitionDuration: "" + react_theme_1.tokens.durationSlow,
                transitionTimingFunction: "" + react_theme_1.tokens.curveDecelerateMax,
            },
            '@media (prefers-reduced-motion: reduce)': {
                '::after': {
                    transitionProperty: 'none',
                    transitionDuration: '0.01ms',
                },
            },
        },
        horizontal: {
            '::after': {
                transformOrigin: 'left',
                transform: "translateX(var(" + tabIndicatorCssVars_unstable.offsetVar + "))\n    scaleX(var(" + tabIndicatorCssVars_unstable.scaleVar + "))",
            },
        },
        vertical: {
            '::after': {
                transformOrigin: 'top',
                transform: "translateY(var(" + tabIndicatorCssVars_unstable.offsetVar + "))\n        scaleY(var(" + tabIndicatorCssVars_unstable.scaleVar + "))",
            },
        },
    });
    var calculateTabRect = function (element) {
        var _a;
        if (element) {
            var parentRect = ((_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || { x: 0, y: 0, width: 0, height: 0 };
            var tabRect = element.getBoundingClientRect();
            return {
                x: tabRect.x - parentRect.x,
                y: tabRect.y - parentRect.y,
                width: tabRect.width,
                height: tabRect.height,
            };
        }
        return undefined;
    };
    var getRegisteredTabRect = function (registeredTabs, value) {
        var _a;
        var element = value !== undefined && value !== null ? (_a = registeredTabs[JSON.stringify(value)]) === null || _a === void 0 ? void 0 : _a.ref.current : undefined;
        return element ? calculateTabRect(element) : undefined;
    };
    /**
     * Adds additional styling to the active tab selection indicator to create a sliding animation.
     */
    var useTabAnimatedIndicatorStyles_unstable = function (state) {
        var _a;
        var disabled = state.disabled, selected = state.selected, vertical = state.vertical;
        var activeIndicatorStyles = useActiveIndicatorStyles();
        var _b = React.useState(), lastAnimatedFrom = _b[0], setLastAnimatedFrom = _b[1];
        var _c = React.useState({ offset: 0, scale: 1 }), animationValues = _c[0], setAnimationValues = _c[1];
        var getRegisteredTabs = react_context_selector_1.useContextSelector(TabListContext_1.TabListContext, function (ctx) { return ctx.getRegisteredTabs; });
        React.useEffect(function () {
            if (lastAnimatedFrom) {
                setAnimationValues({ offset: 0, scale: 1 });
            }
        }, [lastAnimatedFrom]);
        if (selected) {
            var _d = getRegisteredTabs(), previousSelectedValue = _d.previousSelectedValue, selectedValue = _d.selectedValue, registeredTabs = _d.registeredTabs;
            var previousSelectedTabRect = getRegisteredTabRect(registeredTabs, previousSelectedValue);
            var selectedTabRect = getRegisteredTabRect(registeredTabs, selectedValue);
            if (selectedTabRect &&
                previousSelectedTabRect &&
                previousSelectedValue &&
                lastAnimatedFrom !== previousSelectedValue) {
                var offset = vertical
                    ? previousSelectedTabRect.y - selectedTabRect.y
                    : previousSelectedTabRect.x - selectedTabRect.x;
                var scale = vertical
                    ? previousSelectedTabRect.height / selectedTabRect.height
                    : previousSelectedTabRect.width / selectedTabRect.width;
                setAnimationValues({ offset: offset, scale: scale });
                setLastAnimatedFrom(previousSelectedValue);
            }
        }
        else if (lastAnimatedFrom) {
            // need to clear the last animated from so that if this tab is selected again
            // from the same previous tab as last time, that animation still happens.
            setLastAnimatedFrom(undefined);
        }
        // do not apply any animation if the tab is disabled
        if (disabled) {
            return state;
        }
        // the animation should only happen as the selection indicator returns to its
        // original position and not when set at the previous tabs position.
        var animating = animationValues.offset === 0 && animationValues.scale === 1;
        state.root.className = react_1.mergeClasses(state.root.className, selected && activeIndicatorStyles.base, selected && animating && activeIndicatorStyles.animated, selected && (vertical ? activeIndicatorStyles.vertical : activeIndicatorStyles.horizontal));
        var rootCssVars = (_a = {},
            _a[tabIndicatorCssVars_unstable.offsetVar] = animationValues.offset + "px",
            _a[tabIndicatorCssVars_unstable.scaleVar] = "" + animationValues.scale,
            _a);
        state.root.style = tslib_1.__assign(tslib_1.__assign({}, rootCssVars), state.root.style);
        return state;
    };
    exports.useTabAnimatedIndicatorStyles_unstable = useTabAnimatedIndicatorStyles_unstable;
});
//# sourceMappingURL=useTabAnimatedIndicator.js.map