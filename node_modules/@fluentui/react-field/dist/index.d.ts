/// <reference types="react" />

import type { ComponentProps } from '@fluentui/react-utilities';
import type { ComponentState } from '@fluentui/react-utilities';
import { Label } from '@fluentui/react-label';
import * as React_2 from 'react';
import type { Slot } from '@fluentui/react-utilities';
import type { SlotClassNames } from '@fluentui/react-utilities';
import type { SlotRenderFunction } from '@fluentui/react-utilities';
import type { SlotShorthandValue } from '@fluentui/react-utilities';

/**
 * Configuration parameters for a Field class, passed to useField_unstable
 */
export declare type FieldConfig<T extends FieldControl> = {
    /**
     * The underlying input component that this field is wrapping.
     */
    component: T;
    /**
     * Class names for this component, created by `getFieldClassNames`.
     */
    classNames: SlotClassNames<FieldSlots<T>>;
    /**
     * How the label be connected to the control.
     * * htmlFor - Set the Label's htmlFor prop to the component's ID (and generate an ID if not provided).
     *   This is the preferred method for components that use the underlying <input> tag.
     * * aria-labelledby - Set the component's aria-labelledby prop to the Label's ID. Use this for components
     *   that are not directly <input> elements (such as RadioGroup).
     *
     * @default htmlFor
     */
    labelConnection?: 'htmlFor' | 'aria-labelledby';
    /**
     * Should the aria-invalid attribute be set when validationState="error".
     *
     * @default true
     */
    ariaInvalidOnError?: boolean;
};

/**
 * The minimum requirement for a component used by Field.
 *
 * Note: the use of VoidFunctionComponent means that component is not *required* to have a children prop,
 * but it is still allowed to have a children prop.
 */
export declare type FieldControl = React_2.VoidFunctionComponent<Pick<React_2.HTMLAttributes<HTMLElement>, 'id' | 'className' | 'style' | 'aria-labelledby' | 'aria-describedby' | 'aria-invalid'>>;

/**
 * Field Props
 */
export declare type FieldProps<T extends FieldControl> = ComponentProps<Partial<FieldSlots<T>>, 'control'> & {
    /**
     * The orientation of the label relative to the field component.
     * This only affects the label, and not the validationMessage or hint (which always appear below the field component).
     *
     * @default vertical
     */
    orientation?: 'vertical' | 'horizontal';
    /**
     * The `validationState` affects the color of the `validationMessage`, the `validationMessageIcon`, and for some
     * field components, an `validationState="error"` causes the border to become red.
     *
     * @default undefined
     */
    validationState?: 'error' | 'warning' | 'success';
};

/**
 * FieldProps plus extra optional props that are supported by useField_unstable, but not required to be part of the
 * API of every Field component.
 *
 * This allows Field to forward the required and size props to the label if the underlying component supports them,
 * but doesn't add them to the public API of fields that don't support them.
 */
declare type FieldPropsWithOptionalComponentProps<T extends FieldControl> = FieldProps<T> & {
    /**
     * A ref to the underlying control.
     */
    ref?: React_2.Ref<HTMLElement>;
    /**
     * Whether the field label should be marked as required.
     */
    required?: boolean;
    /**
     * Size of the field label.
     *
     * Number sizes will be ignored, but are allowed because the HTML `<input>` element has a prop `size?: number`.
     */
    size?: 'small' | 'medium' | 'large' | number;
};

/**
 * Slots added by Field
 */
export declare type FieldSlots<T extends FieldControl> = {
    root: NonNullable<Slot<'div'>>;
    /**
     * The underlying component wrapped by this field.
     */
    control: SlotComponent<T>;
    /**
     * The label associated with the field.
     */
    label?: Slot<typeof Label>;
    /**
     * A message about the validation state. The appearance of the `validationMessage` depends on `validationState`.
     */
    validationMessage?: Slot<'div'>;
    /**
     * The icon associated with the `validationMessage`. If the `validationState` prop is set, this will default to an
     * icon corresponding to that state.
     *
     * This will only be displayed if `validationMessage` is set.
     */
    validationMessageIcon?: Slot<'span'>;
    /**
     * Additional hint text below the field.
     */
    hint?: Slot<'div'>;
};

/**
 * State used in rendering Field
 */
export declare type FieldState<T extends FieldControl> = ComponentState<Required<FieldSlots<T>>> & Pick<FieldProps<T>, 'orientation' | 'validationState'> & {
    classNames: SlotClassNames<FieldSlots<T>>;
};

export declare const getFieldClassNames: (name: string) => SlotClassNames<FieldSlots<FieldControl>>;

/**
 * Render the final JSX of Field
 */
export declare const renderField_unstable: <T extends FieldControl>(state: FieldState<T>) => JSX.Element;

declare type SlotComponent<Type extends React_2.ComponentType | React_2.VoidFunctionComponent> = WithSlotShorthandValue<Type extends React_2.ComponentType<infer Props> ? WithSlotRenderFunction<Props extends {
    children?: unknown;
} ? Props : Props & {
    children?: never;
}> : never>;

/**
 * Create the state required to render Field.
 *
 * The returned state can be modified with hooks such as useFieldStyles_unstable,
 * before being passed to renderField_unstable.
 *
 * @param props - Props passed to this field
 * @param ref - Ref to the control slot (primary slot)
 * @param params - Configuration parameters for this Field
 */
export declare const useField_unstable: <T extends FieldControl>(props: FieldPropsWithOptionalComponentProps<T>, ref: React_2.Ref<HTMLElement>, params: FieldConfig<T>) => FieldState<T>;

/**
 * Apply styling to the Field slots based on the state
 */
export declare const useFieldStyles_unstable: <T extends FieldControl>(state: FieldState<T>) => void;

declare type WithSlotRenderFunction<Props extends {
    children?: unknown;
}> = Props & {
    children?: Props['children'] | SlotRenderFunction<Props>;
};

declare type WithSlotShorthandValue<Props extends {
    children?: unknown;
}> = Props | Extract<SlotShorthandValue, Props['children']>;

export { }
