define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasScrollParent = exports.getScrollParent = exports.getParentNode = void 0;
    /**
     * Returns the parent node or the host of the node argument.
     * @param node - DOM node.
     * @returns - parent DOM node.
     */
    var getParentNode = function (node) {
        if (node.nodeName === 'HTML') {
            return node;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return node.parentNode || node.host;
    };
    exports.getParentNode = getParentNode;
    /**
     * Returns CSS styles of the given node.
     * @param node - DOM node.
     * @returns - CSS styles.
     */
    var getStyleComputedProperty = function (node) {
        var _a;
        if (node.nodeType !== 1) {
            return {};
        }
        var window = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
        return window.getComputedStyle(node, null);
    };
    /**
     * Returns the first scrollable parent of the given element.
     * @param node - DOM node.
     * @returns - the first scrollable parent.
     */
    var getScrollParent = function (node) {
        // Return body, `getScroll` will take care to get the correct `scrollTop` from it
        var parentNode = node && exports.getParentNode(node);
        // eslint-disable-next-line
        if (!parentNode)
            return document.body;
        switch (parentNode.nodeName) {
            case 'HTML':
            case 'BODY':
                return parentNode.ownerDocument.body;
            case '#document':
                return parentNode.body;
        }
        // If any of the overflow props is defined for the node then we return it as the parent
        var _a = getStyleComputedProperty(parentNode), overflow = _a.overflow, overflowX = _a.overflowX, overflowY = _a.overflowY;
        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
            return parentNode;
        }
        return exports.getScrollParent(parentNode);
    };
    exports.getScrollParent = getScrollParent;
    var hasScrollParent = function (node) {
        var _a;
        var scrollParentElement = exports.getScrollParent(node);
        return scrollParentElement ? scrollParentElement !== ((_a = scrollParentElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.body) : false;
    };
    exports.hasScrollParent = hasScrollParent;
});
//# sourceMappingURL=getScrollParent.js.map