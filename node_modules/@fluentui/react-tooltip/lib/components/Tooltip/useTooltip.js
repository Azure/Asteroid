import * as React from 'react';
import { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';
import { useTooltipVisibility_unstable as useTooltipVisibility, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { applyTriggerPropsToChildren, resolveShorthand, useControllableState, useId, useIsomorphicLayoutEffect, useIsSSR, useMergedRefs, useTimeout, getTriggerChild, mergeCallbacks, useEventCallback } from '@fluentui/react-utilities';
import { arrowHeight, tooltipBorderRadius } from './private/constants';
import { Escape } from '@fluentui/keyboard-keys';
/**
 * Create the state required to render Tooltip.
 *
 * The returned state can be modified with hooks such as useTooltipStyles_unstable,
 * before being passed to renderTooltip_unstable.
 *
 * @param props - props from this instance of Tooltip
 */

export const useTooltip_unstable = props => {
  var _a, _b, _c, _d;

  const context = useTooltipVisibility();
  const isServerSideRender = useIsSSR();
  const {
    targetDocument
  } = useFluent();
  const [setDelayTimeout, clearDelayTimeout] = useTimeout();
  const {
    appearance = 'normal',
    children,
    content,
    withArrow = false,
    positioning = 'above',
    onVisibleChange,
    relationship,
    showDelay = 250,
    hideDelay = 250,
    mountNode
  } = props;
  const [visible, setVisibleInternal] = useControllableState({
    state: props.visible,
    initialState: false
  });
  const setVisible = React.useCallback((newVisible, ev) => {
    clearDelayTimeout();
    setVisibleInternal(oldVisible => {
      if (newVisible !== oldVisible) {
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, {
          visible: newVisible
        });
      }

      return newVisible;
    });
  }, [clearDelayTimeout, setVisibleInternal, onVisibleChange]);
  const state = {
    withArrow,
    positioning,
    showDelay,
    hideDelay,
    relationship,
    visible,
    shouldRenderTooltip: visible,
    appearance,
    mountNode,
    // Slots
    components: {
      content: 'div'
    },
    content: resolveShorthand(content, {
      defaultProps: {
        role: 'tooltip'
      },
      required: true
    })
  };
  state.content.id = useId('tooltip-', state.content.id);
  const positioningOptions = {
    enabled: state.visible,
    arrowPadding: 2 * tooltipBorderRadius,
    position: 'above',
    align: 'center',
    offset: 4,
    ...resolvePositioningShorthand(state.positioning)
  };

  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);
  }

  const {
    targetRef,
    containerRef,
    arrowRef
  } = usePositioning(positioningOptions);
  state.content.ref = useMergedRefs(state.content.ref, containerRef);
  state.arrowRef = arrowRef; // When this tooltip is visible, hide any other tooltips, and register it
  // as the visibleTooltip with the TooltipContext.
  // Also add a listener on document to hide the tooltip if Escape is pressed

  useIsomorphicLayoutEffect(() => {
    var _a;

    if (visible) {
      const thisTooltip = {
        hide: () => setVisible(false)
      };
      (_a = context.visibleTooltip) === null || _a === void 0 ? void 0 : _a.hide();
      context.visibleTooltip = thisTooltip;

      const onDocumentKeyDown = ev => {
        if (ev.key === Escape) {
          thisTooltip.hide(); // stop propagation to avoid conflicting with other elements that listen for `Escape`
          // e,g: Dialog, Popover, Menu

          ev.stopPropagation();
        }
      };

      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('keydown', onDocumentKeyDown, {
        // As this event is added at targeted document,
        // we need to capture the event to be sure keydown handling from tooltip happens first
        capture: true
      });
      return () => {
        if (context.visibleTooltip === thisTooltip) {
          context.visibleTooltip = undefined;
        }

        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('keydown', onDocumentKeyDown, {
          capture: true
        });
      };
    }
  }, [context, targetDocument, visible, setVisible]); // The focused element gets a blur event when the document loses focus
  // (e.g. switching tabs in the browser), but we don't want to show the
  // tooltip again when the document gets focus back. Handle this case by
  // checking if the blurred element is still the document's activeElement.
  // See https://github.com/microsoft/fluentui/issues/13541

  const ignoreNextFocusEventRef = React.useRef(false); // Listener for onPointerEnter and onFocus on the trigger element

  const onEnterTrigger = React.useCallback(ev => {
    if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {
      ignoreNextFocusEventRef.current = false;
      return;
    } // Show immediately if another tooltip is already visible


    const delay = context.visibleTooltip ? 0 : state.showDelay;
    setDelayTimeout(() => {
      setVisible(true, ev);
    }, delay);
    ev.persist(); // Persist the event since the setVisible call will happen asynchronously
  }, [setDelayTimeout, setVisible, state.showDelay, context]); // Listener for onPointerLeave and onBlur on the trigger element

  const onLeaveTrigger = React.useCallback(ev => {
    let delay = state.hideDelay;

    if (ev.type === 'blur') {
      // Hide immediately when losing focus
      delay = 0;
      ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
    }

    setDelayTimeout(() => {
      setVisible(false, ev);
    }, delay);
    ev.persist(); // Persist the event since the setVisible call will happen asynchronously
  }, [setDelayTimeout, setVisible, state.hideDelay, targetDocument]); // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.
  // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.

  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);
  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);
  const child = getTriggerChild(children);
  const triggerAriaProps = {};

  if (relationship === 'label') {
    // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.
    if (typeof state.content.children === 'string') {
      triggerAriaProps['aria-label'] = state.content.children;
    } else {
      triggerAriaProps['aria-labelledby'] = state.content.id; // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element

      state.shouldRenderTooltip = true;
    }
  } else if (relationship === 'description') {
    triggerAriaProps['aria-describedby'] = state.content.id; // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element

    state.shouldRenderTooltip = true;
  } // Don't render the Tooltip in SSR to avoid hydration errors


  if (isServerSideRender) {
    state.shouldRenderTooltip = false;
  }

  const childTargetRef = useMergedRefs(child === null || child === void 0 ? void 0 : child.ref, targetRef); // Apply the trigger props to the child, either by calling the render function, or cloning with the new props

  state.children = applyTriggerPropsToChildren(children, { ...triggerAriaProps,
    ...(child === null || child === void 0 ? void 0 : child.props),
    // If the target prop is not provided, attach targetRef to the trigger element's ref prop
    ref: positioningOptions.target === undefined ? childTargetRef : child === null || child === void 0 ? void 0 : child.ref,
    onPointerEnter: useEventCallback(mergeCallbacks((_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.onPointerEnter, onEnterTrigger)),
    onPointerLeave: useEventCallback(mergeCallbacks((_b = child === null || child === void 0 ? void 0 : child.props) === null || _b === void 0 ? void 0 : _b.onPointerLeave, onLeaveTrigger)),
    onFocus: useEventCallback(mergeCallbacks((_c = child === null || child === void 0 ? void 0 : child.props) === null || _c === void 0 ? void 0 : _c.onFocus, onEnterTrigger)),
    onBlur: useEventCallback(mergeCallbacks((_d = child === null || child === void 0 ? void 0 : child.props) === null || _d === void 0 ? void 0 : _d.onBlur, onLeaveTrigger))
  });
  return state;
};
//# sourceMappingURL=useTooltip.js.map