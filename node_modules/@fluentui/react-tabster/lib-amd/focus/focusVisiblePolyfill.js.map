{"version":3,"file":"focusVisiblePolyfill.js","sourceRoot":"","sources":["../../../../../../../../packages/react-components/react-tabster/src/focus/focusVisiblePolyfill.ts"],"names":[],"mappings":"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","sourcesContent":["import { KEYBORG_FOCUSIN, KeyborgFocusInEvent, createKeyborg, disposeKeyborg } from 'keyborg';\nimport { FOCUS_VISIBLE_ATTR } from './constants';\n\n/**\n * Because `addEventListener` type override falls back to 2nd definition (evt name is unknown string literal)\n * evt is being typed as a base class of MouseEvent -> `Event`.\n * This type is used to override `listener` calls to make TS happy\n */\ntype ListenerOverride = (evt: Event) => void;\n\ntype FocusVisibleState = {\n  /**\n   * Current element with focus visible in state\n   */\n  current: HTMLElement | undefined;\n};\n\ntype HTMLElementWithFocusVisibleScope = {\n  focusVisible: boolean | undefined;\n} & HTMLElement;\n\n/**\n * @internal\n * @param scope - Applies the ponyfill to all DOM children\n * @param win - window\n */\nexport function applyFocusVisiblePolyfill(scope: HTMLElement, win: Window): () => void {\n  if (alreadyInScope(scope)) {\n    // Focus visible polyfill already applied at this scope\n    return () => undefined;\n  }\n\n  const state: FocusVisibleState = {\n    current: undefined,\n  };\n\n  const keyborg = createKeyborg(win);\n\n  // When navigation mode changes remove the focus-visible selector\n  keyborg.subscribe(isNavigatingWithKeyboard => {\n    if (!isNavigatingWithKeyboard && state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n  });\n\n  // Keyborg's focusin event is delegated so it's only registered once on the window\n  // and contains metadata about the focus event\n  const keyborgListener = (e: KeyborgFocusInEvent) => {\n    if (state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n\n    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e.target) && e.target) {\n      // Griffel can't create chained global styles so use the parent element for now\n      state.current = e.target;\n      applyFocusVisibleClass(state.current);\n    }\n  };\n\n  // Make sure that when focus leaves the scope, the focus visible class is removed\n  const blurListener = (e: FocusEvent) => {\n    if (!e.relatedTarget || (isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget))) {\n      if (state.current) {\n        removeFocusVisibleClass(state.current);\n        state.current = undefined;\n      }\n    }\n  };\n\n  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener as ListenerOverride);\n  scope.addEventListener('focusout', blurListener);\n  (scope as HTMLElementWithFocusVisibleScope).focusVisible = true;\n\n  // Return disposer\n  return () => {\n    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener as ListenerOverride);\n    scope.removeEventListener('focusout', blurListener);\n    delete (scope as HTMLElementWithFocusVisibleScope).focusVisible;\n    disposeKeyborg(keyborg);\n  };\n}\n\nfunction applyFocusVisibleClass(el: HTMLElement) {\n  el.setAttribute(FOCUS_VISIBLE_ATTR, '');\n}\n\nfunction removeFocusVisibleClass(el: HTMLElement) {\n  el.removeAttribute(FOCUS_VISIBLE_ATTR);\n}\n\nfunction isHTMLElement(target: EventTarget | null): target is HTMLElement {\n  if (!target) {\n    return false;\n  }\n  return Boolean(target && typeof target === 'object' && 'classList' in target && 'contains' in target);\n}\n\nfunction alreadyInScope(el: HTMLElement | null | undefined): boolean {\n  if (!el) {\n    return false;\n  }\n\n  if ((el as HTMLElementWithFocusVisibleScope).focusVisible) {\n    return true;\n  }\n\n  return alreadyInScope(el?.parentElement);\n}\n"]}