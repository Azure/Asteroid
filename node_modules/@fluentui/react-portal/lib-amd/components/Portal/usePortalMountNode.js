define(["require", "exports", "react", "@fluentui/react-shared-contexts", "@griffel/react", "@fluentui/react-tabster"], function (require, exports, React, react_shared_contexts_1, react_1, react_tabster_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.usePortalMountNode = void 0;
    var useStyles = react_1.makeStyles({
        root: {
            position: 'relative',
            zIndex: 1000000,
        },
    });
    /**
     * Creates a new element on a document.body to mount portals
     */
    var usePortalMountNode = function (options) {
        var _a = react_shared_contexts_1.useFluent_unstable(), targetDocument = _a.targetDocument, dir = _a.dir;
        var focusVisibleRef = react_tabster_1.useFocusVisible();
        var classes = useStyles();
        var themeClassName = react_shared_contexts_1.useThemeClassName_unstable();
        var className = react_1.mergeClasses(themeClassName, classes.root);
        var element = React.useMemo(function () {
            if (targetDocument === undefined || options.disabled) {
                return null;
            }
            var newElement = targetDocument.createElement('div');
            targetDocument.body.appendChild(newElement);
            return newElement;
        }, [targetDocument, options.disabled]);
        // This useMemo call is intentional
        // We don't want to re-create the portal element when its attributes change.
        // This also should not be done in an effect because, changing the value of css variables
        // after initial mount can trigger interesting CSS side effects like transitions.
        React.useMemo(function () {
            var _a;
            if (element) {
                var classesToApply_1 = className.split(' ').filter(Boolean);
                (_a = element.classList).add.apply(_a, classesToApply_1);
                element.setAttribute('dir', dir);
                focusVisibleRef.current = element;
                return function () {
                    var _a;
                    (_a = element.classList).remove.apply(_a, classesToApply_1);
                    element.removeAttribute('dir');
                };
            }
        }, [className, dir, element, focusVisibleRef]);
        React.useEffect(function () {
            return function () {
                var _a;
                (_a = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);
            };
        }, [element]);
        return element;
    };
    exports.usePortalMountNode = usePortalMountNode;
});
//# sourceMappingURL=usePortalMountNode.js.map