"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMenuEnterEvent = exports.useOnMenuMouseEnter = exports.MENU_ENTER_EVENT = void 0;

const React = /*#__PURE__*/require("react");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_portal_1 = /*#__PURE__*/require("@fluentui/react-portal");
/**
 * Name of the custom event
 */


exports.MENU_ENTER_EVENT = 'fuimenuenter';
/**
 * This hook works similarly to @see {useOnClickOutside}
 *
 * Problem: Trying to behave the same as system menus:
 * When the mouse leaves a stack of nested menus the stack should not dismiss.
 * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.
 *
 * We don't use the native mouseenter event because it would trigger too many times in the document
 * Instead, dispatch custom DOM event from the menu so that it can bubble
 * Each nested menu can use the listener to check if the event is from a child or parent menu
 */

const useOnMenuMouseEnter = options => {
  const {
    refs,
    callback,
    element,
    disabled
  } = options; // Keep mouse event here because this is essentially a custom 'mouseenter' event

  const listener = react_utilities_1.useEventCallback(ev => {
    var _a;

    const popoverRef = refs[0];
    const someMenuPopover = ev.target; // someMenu is a child -> will always be contained because of vParents
    // someMenu is a parent -> will always not be contained because no vParent
    // someMenu is the current popover -> it will contain itself

    const isOutsidePopover = !react_portal_1.elementContains((_a = popoverRef.current) !== null && _a !== void 0 ? _a : null, someMenuPopover);

    if (isOutsidePopover && !disabled) {
      callback(ev);
    }
  });
  React.useEffect(() => {
    // eslint-disable-next-line eqeqeq
    if (element == null) {
      return;
    }

    if (!disabled) {
      element.addEventListener(exports.MENU_ENTER_EVENT, listener);
    }

    return () => {
      element.removeEventListener(exports.MENU_ENTER_EVENT, listener);
    };
  }, [listener, element, disabled]);
};

exports.useOnMenuMouseEnter = useOnMenuMouseEnter;
/**
 * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`
 * @param el element for the event target
 * @param nativeEvent the native mouse event this is mapped to
 */

const dispatchMenuEnterEvent = (el, nativeEvent) => {
  el.dispatchEvent(new CustomEvent(exports.MENU_ENTER_EVENT, {
    bubbles: true,
    detail: {
      nativeEvent
    }
  }));
};

exports.dispatchMenuEnterEvent = dispatchMenuEnterEvent;
//# sourceMappingURL=useOnMenuEnter.js.map