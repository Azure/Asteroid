"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMenuTrigger_unstable = void 0;

const React = /*#__PURE__*/require("react");

const menuContext_1 = /*#__PURE__*/require("../../contexts/menuContext");

const useIsSubmenu_1 = /*#__PURE__*/require("../../utils/useIsSubmenu");

const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");

const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");

const keyboard_keys_1 = /*#__PURE__*/require("@fluentui/keyboard-keys");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_aria_1 = /*#__PURE__*/require("@fluentui/react-aria");
/**
 * Create the state required to render MenuTrigger.
 * Clones the only child component and adds necessary event handling behaviours to open a popup menu
 *
 * @param props - props from this instance of MenuTrigger
 */


const useMenuTrigger_unstable = props => {
  const {
    children,
    disableButtonEnhancement = false
  } = props;
  const triggerRef = menuContext_1.useMenuContext_unstable(context => context.triggerRef);
  const menuPopoverRef = menuContext_1.useMenuContext_unstable(context => context.menuPopoverRef);
  const setOpen = menuContext_1.useMenuContext_unstable(context => context.setOpen);
  const open = menuContext_1.useMenuContext_unstable(context => context.open);
  const triggerId = menuContext_1.useMenuContext_unstable(context => context.triggerId);
  const openOnHover = menuContext_1.useMenuContext_unstable(context => context.openOnHover);
  const openOnContext = menuContext_1.useMenuContext_unstable(context => context.openOnContext);
  const isSubmenu = useIsSubmenu_1.useIsSubmenu();
  const {
    findFirstFocusable
  } = react_tabster_1.useFocusFinders();
  const focusFirst = React.useCallback(() => {
    const firstFocusable = findFirstFocusable(menuPopoverRef.current);
    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
  }, [findFirstFocusable, menuPopoverRef]);
  const openedWithKeyboardRef = React.useRef(false);
  const hasMouseMoved = React.useRef(false);
  const {
    dir
  } = react_shared_contexts_1.useFluent_unstable();
  const OpenArrowKey = dir === 'ltr' ? keyboard_keys_1.ArrowRight : keyboard_keys_1.ArrowLeft;
  const child = react_utilities_1.getTriggerChild(children);

  const onContextMenu = event => {
    if (isTargetDisabled(event)) {
      return;
    }

    if (openOnContext) {
      event.preventDefault();
      setOpen(event, {
        open: true,
        keyboard: false,
        type: 'menuTriggerContextMenu',
        event
      });
    }
  };

  const onClick = event => {
    if (isTargetDisabled(event)) {
      return;
    }

    if (!openOnContext) {
      setOpen(event, {
        open: !open,
        keyboard: openedWithKeyboardRef.current,
        type: 'menuTriggerClick',
        event
      });
      openedWithKeyboardRef.current = false;
    }
  };

  const onKeyDown = event => {
    if (isTargetDisabled(event)) {
      return;
    }

    const key = event.key;

    if (!openOnContext && (isSubmenu && key === OpenArrowKey || !isSubmenu && key === keyboard_keys_1.ArrowDown)) {
      setOpen(event, {
        open: true,
        keyboard: true,
        type: 'menuTriggerKeyDown',
        event
      });
    }

    if (key === keyboard_keys_1.Escape && !isSubmenu) {
      setOpen(event, {
        open: false,
        keyboard: true,
        type: 'menuTriggerKeyDown',
        event
      });
    } // if menu is already open, can't rely on effects to focus


    if (open && key === OpenArrowKey && isSubmenu) {
      focusFirst();
    }
  };

  const onMouseEnter = event => {
    if (isTargetDisabled(event)) {
      return;
    }

    if (openOnHover && hasMouseMoved.current) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: 'menuTriggerMouseEnter',
        event
      });
    }
  }; // Opening a menu when a mouse hasn't moved and just entering the trigger is a bad a11y experience
  // First time open the mouse using mousemove and then continue with mouseenter
  // Only use once to determine that the user is using the mouse since it is an expensive event to handle


  const onMouseMove = event => {
    if (isTargetDisabled(event)) {
      return;
    }

    if (openOnHover && !hasMouseMoved.current) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: 'menuTriggerMouseMove',
        event
      });
      hasMouseMoved.current = true;
    }
  };

  const onMouseLeave = event => {
    if (isTargetDisabled(event)) {
      return;
    }

    if (openOnHover) {
      setOpen(event, {
        open: false,
        keyboard: false,
        type: 'menuTriggerMouseLeave',
        event
      });
    }
  };

  const contextMenuProps = {
    id: triggerId,
    ...(child === null || child === void 0 ? void 0 : child.props),
    ref: react_utilities_1.useMergedRefs(triggerRef, child === null || child === void 0 ? void 0 : child.ref),
    onMouseEnter: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
    onMouseLeave: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
    onContextMenu: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
    onMouseMove: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove))
  };
  const triggerChildProps = {
    'aria-haspopup': 'menu',
    'aria-expanded': !open && !isSubmenu ? undefined : open,
    ...contextMenuProps,
    onClick: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
    onKeyDown: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
  };
  const ariaButtonTriggerChildProps = react_aria_1.useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === 'button' || (child === null || child === void 0 ? void 0 : child.type) === 'a' ? child.type : 'div', triggerChildProps);
  return {
    isSubmenu,
    children: react_utilities_1.applyTriggerPropsToChildren(children, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};

exports.useMenuTrigger_unstable = useMenuTrigger_unstable;

const isTargetDisabled = e => {
  const isDisabled = el => el.hasAttribute('disabled') || el.hasAttribute('aria-disabled') && el.getAttribute('aria-disabled') === 'true';

  if (e.target instanceof HTMLElement && isDisabled(e.target)) {
    return true;
  }

  return e.currentTarget instanceof HTMLElement && isDisabled(e.currentTarget);
};
//# sourceMappingURL=useMenuTrigger.js.map