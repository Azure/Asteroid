define(["require", "exports", "tslib", "react", "@fluentui/keyboard-keys", "@fluentui/react-utilities", "../../contexts/menuContext", "../../utils/index", "@fluentui/react-shared-contexts", "../../utils/useIsSubmenu"], function (require, exports, tslib_1, React, keyboard_keys_1, react_utilities_1, menuContext_1, index_1, react_shared_contexts_1, useIsSubmenu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMenuPopover_unstable = void 0;
    /**
     * Create the state required to render MenuPopover.
     *
     * The returned state can be modified with hooks such as useMenuPopoverStyles_unstable,
     * before being passed to renderMenuPopover_unstable.
     *
     * @param props - props from this instance of MenuPopover
     * @param ref - reference to root HTMLElement of MenuPopover
     */
    var useMenuPopover_unstable = function (props, ref) {
        var _a;
        var popoverRef = menuContext_1.useMenuContext_unstable(function (context) { return context.menuPopoverRef; });
        var setOpen = menuContext_1.useMenuContext_unstable(function (context) { return context.setOpen; });
        var open = menuContext_1.useMenuContext_unstable(function (context) { return context.open; });
        var openOnHover = menuContext_1.useMenuContext_unstable(function (context) { return context.openOnHover; });
        var isSubmenu = useIsSubmenu_1.useIsSubmenu();
        var canDispatchCustomEventRef = React.useRef(true);
        var throttleDispatchTimerRef = React.useRef(0);
        var dir = react_shared_contexts_1.useFluent_unstable().dir;
        var CloseArrowKey = dir === 'ltr' ? keyboard_keys_1.ArrowLeft : keyboard_keys_1.ArrowRight;
        // use DOM listener since react events propagate up the react tree
        // no need to do `contains` logic as menus are all positioned in different portals
        var mouseOverListenerCallbackRef = React.useCallback(function (node) {
            if (node) {
                // Dispatches the custom menu mouse enter event with throttling
                // Needs to trigger on mouseover to support keyboard + mouse together
                // i.e. keyboard opens submenus while cursor is still on the parent
                node.addEventListener('mouseover', function (e) {
                    if (canDispatchCustomEventRef.current) {
                        canDispatchCustomEventRef.current = false;
                        index_1.dispatchMenuEnterEvent(popoverRef.current, e);
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore #16889 Node setTimeout type leaking
                        throttleDispatchTimerRef.current = setTimeout(function () { return (canDispatchCustomEventRef.current = true); }, 250);
                    }
                });
            }
        }, [popoverRef, throttleDispatchTimerRef]);
        React.useEffect(function () {
            (function () { return clearTimeout(throttleDispatchTimerRef.current); });
        }, []);
        var inline = (_a = menuContext_1.useMenuContext_unstable(function (context) { return context.inline; })) !== null && _a !== void 0 ? _a : false;
        var rootProps = react_utilities_1.getNativeElementProps('div', tslib_1.__assign(tslib_1.__assign({ role: 'presentation' }, props), { ref: react_utilities_1.useMergedRefs(ref, popoverRef, mouseOverListenerCallbackRef) }));
        var onMouseEnterOriginal = rootProps.onMouseEnter, onKeyDownOriginal = rootProps.onKeyDown;
        rootProps.onMouseEnter = react_utilities_1.useEventCallback(function (event) {
            if (openOnHover) {
                setOpen(event, { open: true, keyboard: false, type: 'menuPopoverMouseEnter', event: event });
            }
            onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(event);
        });
        rootProps.onKeyDown = react_utilities_1.useEventCallback(function (event) {
            var _a;
            var key = event.key;
            if (key === keyboard_keys_1.Escape || (isSubmenu && key === CloseArrowKey)) {
                if (open && ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {
                    setOpen(event, { open: false, keyboard: true, type: 'menuPopoverKeyDown', event: event });
                    // stop propagation to avoid conflicting with other elements that listen for `Escape`
                    // e,g: Dialog, Popover and Tooltip
                    event.stopPropagation();
                }
            }
            if (key === keyboard_keys_1.Tab) {
                setOpen(event, { open: false, keyboard: true, type: 'menuPopoverKeyDown', event: event });
                event.preventDefault();
            }
            onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(event);
        });
        return {
            inline: inline,
            components: {
                root: 'div',
            },
            root: rootProps,
        };
    };
    exports.useMenuPopover_unstable = useMenuPopover_unstable;
});
//# sourceMappingURL=useMenuPopover.js.map