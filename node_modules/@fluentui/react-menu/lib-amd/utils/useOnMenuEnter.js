define(["require", "exports", "react", "@fluentui/react-utilities", "@fluentui/react-portal"], function (require, exports, React, react_utilities_1, react_portal_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dispatchMenuEnterEvent = exports.useOnMenuMouseEnter = exports.MENU_ENTER_EVENT = void 0;
    /**
     * Name of the custom event
     */
    exports.MENU_ENTER_EVENT = 'fuimenuenter';
    /**
     * This hook works similarly to @see {useOnClickOutside}
     *
     * Problem: Trying to behave the same as system menus:
     * When the mouse leaves a stack of nested menus the stack should not dismiss.
     * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.
     *
     * We don't use the native mouseenter event because it would trigger too many times in the document
     * Instead, dispatch custom DOM event from the menu so that it can bubble
     * Each nested menu can use the listener to check if the event is from a child or parent menu
     */
    var useOnMenuMouseEnter = function (options) {
        var refs = options.refs, callback = options.callback, element = options.element, disabled = options.disabled;
        // Keep mouse event here because this is essentially a custom 'mouseenter' event
        var listener = react_utilities_1.useEventCallback(function (ev) {
            var _a;
            var popoverRef = refs[0];
            var someMenuPopover = ev.target;
            // someMenu is a child -> will always be contained because of vParents
            // someMenu is a parent -> will always not be contained because no vParent
            // someMenu is the current popover -> it will contain itself
            var isOutsidePopover = !react_portal_1.elementContains((_a = popoverRef.current) !== null && _a !== void 0 ? _a : null, someMenuPopover);
            if (isOutsidePopover && !disabled) {
                callback(ev);
            }
        });
        React.useEffect(function () {
            // eslint-disable-next-line eqeqeq
            if (element == null) {
                return;
            }
            if (!disabled) {
                element.addEventListener(exports.MENU_ENTER_EVENT, listener);
            }
            return function () {
                element.removeEventListener(exports.MENU_ENTER_EVENT, listener);
            };
        }, [listener, element, disabled]);
    };
    exports.useOnMenuMouseEnter = useOnMenuMouseEnter;
    /**
     * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`
     * @param el element for the event target
     * @param nativeEvent the native mouse event this is mapped to
     */
    var dispatchMenuEnterEvent = function (el, nativeEvent) {
        el.dispatchEvent(new CustomEvent(exports.MENU_ENTER_EVENT, { bubbles: true, detail: { nativeEvent: nativeEvent } }));
    };
    exports.dispatchMenuEnterEvent = dispatchMenuEnterEvent;
});
//# sourceMappingURL=useOnMenuEnter.js.map