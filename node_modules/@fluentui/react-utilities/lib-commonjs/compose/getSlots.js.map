{"version":3,"sources":["packages/react-components/react-utilities/src/compose/getSlots.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,KAAA,gBAAA,OAAA,CAAA,OAAA,CAAA;;AAEA,MAAA,MAAA,gBAAA,OAAA,CAAA,eAAA,CAAA;AA6BA;;;;;;;;;;;;;;;;AAgBG;;;AACH,SAAgB,QAAhB,CACE,KADF,EAC0B;EAKxB,MAAM,KAAK,GAAG,EAAd;EACA,MAAM,SAAS,GAAG,EAAlB;EAEA,MAAM,SAAS,GAAgB,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,UAAlB,CAA/B;;EACA,KAAK,MAAM,QAAX,IAAuB,SAAvB,EAAkC;IAChC,MAAM,CAAC,IAAD,EAAO,KAAP,IAAgB,OAAO,CAAC,KAAD,EAAQ,QAAR,CAA7B;IACA,KAAK,CAAC,QAAD,CAAL,GAAkB,IAAlB;IACA,SAAS,CAAC,QAAD,CAAT,GAAsB,KAAtB;EACD;;EACD,OAAO;IAAE,KAAF;IAAS,SAAS,EAAG;EAArB,CAAP;AACD;;AAhBD,OAAA,CAAA,QAAA,GAAA,QAAA;;AAkBA,SAAS,OAAT,CACE,KADF,EAEE,QAFF,EAEa;;;EAEX,IAAI,KAAK,CAAC,QAAD,CAAL,KAAoB,SAAxB,EAAmC;IACjC,OAAO,CAAC,IAAD,EAAO,SAAP,CAAP;EACD;;EACD,MAAM;IAAE,QAAF;IAAY,EAAE,EAAE,MAAhB;IAAwB,GAAG;EAA3B,IAAoC,KAAK,CAAC,QAAD,CAA/C;EAEA,MAAM,IAAI,GAAI,CAAA,CAAA,EAAA,GAAA,KAAK,CAAC,UAAN,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAG,QAAH,CAAhB,MAAiC,SAAjC,IAA8C,OAAO,KAAK,CAAC,UAAN,CAAiB,QAAjB,CAAP,KAAsC,QAApF,GACV,MAAM,KAAI,CAAA,EAAA,GAAA,KAAK,CAAC,UAAN,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAG,QAAH,CAApB,CAAN,IAA0C,KADhC,GAEV,KAAK,CAAC,UAAN,CAAiB,QAAjB,CAFJ;;EAIA,IAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;IAClC,MAAM,MAAM,GAAG,QAAf;IACA,OAAO,CACL,KAAK,CAAC,QADD,EAEJ;MACC,QAAQ,EAAE,MAAM,CAAC,IAAD,EAAO,IAAP;IADjB,CAFI,CAAP;EAMD;;EAED,MAAM,gBAAgB,GAAG,OAAO,IAAP,KAAgB,QAAhB,KAA4B,CAAA,EAAA,GAAA,KAAK,CAAC,QAAD,CAAL,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,EAA7C,CAAzB;EACA,MAAM,SAAS,GAAI,gBAAgB,GAAG,MAAA,CAAA,IAAA,CAAK,KAAK,CAAC,QAAD,CAAV,EAAuB,CAAC,IAAD,CAAvB,CAAH,GAAoC,KAAK,CAAC,QAAD,CAA5E;EAEA,OAAO,CAAC,IAAD,EAAO,SAAP,CAAP;AACD","sourcesContent":["import * as React from 'react';\n\nimport { omit } from '../utils/omit';\nimport type {\n  AsIntrinsicElement,\n  ComponentState,\n  ExtractSlotProps,\n  SlotPropsRecord,\n  SlotRenderFunction,\n  UnionToIntersection,\n} from './types';\n\nexport type Slots<S extends SlotPropsRecord> = {\n  [K in keyof S]: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As>\n    ? // for slots with an `as` prop, the slot will be any one of the possible values of `as`\n      As\n    : ExtractSlotProps<S[K]> extends React.ComponentType<infer P>\n    ? React.ElementType<NonNullable<P>>\n    : React.ElementType<ExtractSlotProps<S[K]>>;\n};\n\ntype ObjectSlotProps<S extends SlotPropsRecord> = {\n  [K in keyof S]-?: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As>\n    ? // For intrinsic element types, return the intersection of all possible\n      // element's props, to be compatible with the As type returned by Slots<>\n      UnionToIntersection<JSX.IntrinsicElements[As]>\n    : ExtractSlotProps<S[K]> extends React.ComponentType<infer P>\n    ? P\n    : never;\n};\n\n/**\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\n * collections.\n *\n * The root is derived from a mix of `components` props and `as` prop.\n *\n * Slots will render as null if they are rendered as primitives with undefined children.\n *\n * The slotProps will always omit the `as` prop within them, and for slots that are string\n * primitives, the props will be filtered according to the slot type by the type system.\n * For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable\n * anchor props. Note that this is only enforced at build time by Typescript -- there is no\n * runtime code filtering props in this function.\n *\n * @param state - State including slot definitions\n * @returns An object containing the `slots` map and `slotProps` map.\n */\nexport function getSlots<R extends SlotPropsRecord>(\n  state: ComponentState<R>,\n): {\n  slots: Slots<R>;\n  slotProps: ObjectSlotProps<R>;\n} {\n  const slots = {} as Slots<R>;\n  const slotProps = {} as R;\n\n  const slotNames: (keyof R)[] = Object.keys(state.components);\n  for (const slotName of slotNames) {\n    const [slot, props] = getSlot(state, slotName);\n    slots[slotName] = slot as Slots<R>[typeof slotName];\n    slotProps[slotName] = props;\n  }\n  return { slots, slotProps: (slotProps as unknown) as ObjectSlotProps<R> };\n}\n\nfunction getSlot<R extends SlotPropsRecord, K extends keyof R>(\n  state: ComponentState<R>,\n  slotName: K,\n): readonly [React.ElementType<R[K]> | null, R[K]] {\n  if (state[slotName] === undefined) {\n    return [null, undefined as R[K]];\n  }\n  const { children, as: asProp, ...rest } = state[slotName]!;\n\n  const slot = (state.components?.[slotName] === undefined || typeof state.components[slotName] === 'string'\n    ? asProp || state.components?.[slotName] || 'div'\n    : state.components[slotName]) as React.ElementType<R[K]>;\n\n  if (typeof children === 'function') {\n    const render = children as SlotRenderFunction<R[K]>;\n    return [\n      React.Fragment,\n      ({\n        children: render(slot, rest as Omit<R[K], 'children' | 'as'>),\n      } as unknown) as R[K],\n    ];\n  }\n\n  const shouldOmitAsProp = typeof slot === 'string' && state[slotName]?.as;\n  const slotProps = (shouldOmitAsProp ? omit(state[slotName]!, ['as']) : state[slotName]) as R[K];\n\n  return [slot, slotProps];\n}\n"],"sourceRoot":"../src/"}