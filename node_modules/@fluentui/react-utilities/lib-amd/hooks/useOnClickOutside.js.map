{"version":3,"file":"useOnClickOutside.js","sourceRoot":"","sources":["../../../../../../../../packages/react-components/react-utilities/src/hooks/useOnClickOutside.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useEventCallback } from './useEventCallback';\n\n/**\n * @internal\n */\nexport type UseOnClickOrScrollOutsideOptions = {\n  /**\n   * The element to listen for the click event\n   */\n  element: Document | undefined;\n  /**\n   * Refs to elements that check if the click is outside\n   */\n  refs: React.MutableRefObject<HTMLElement | undefined | null>[];\n\n  /**\n   * By default uses element.contains, but custom contain function can be provided\n   * @param parentRef - provided parent ref\n   * @param child - event target element\n   */\n  contains?(parent: HTMLElement | null, child: HTMLElement): boolean;\n\n  /**\n   * Disables event listeners\n   */\n  disabled?: boolean;\n\n  /**\n   * Called if the click is outside the element refs\n   */\n  callback: (ev: MouseEvent | TouchEvent) => void;\n};\n\n/**\n * @internal\n * Utility to perform checks where a click/touch event was made outside a component\n */\nexport const useOnClickOutside = (options: UseOnClickOrScrollOutsideOptions) => {\n  const { refs, callback, element, disabled, contains: containsProp } = options;\n  const timeoutId = React.useRef<number | undefined>(undefined);\n  useIFrameFocus(!disabled, element, callback as (e: Event) => void);\n\n  const listener = useEventCallback((ev: MouseEvent | TouchEvent) => {\n    const contains: UseOnClickOrScrollOutsideOptions['contains'] =\n      containsProp || ((parent, child) => !!parent?.contains(child));\n\n    const isOutside = refs.every(ref => !contains(ref.current || null, ev.target as HTMLElement));\n    if (isOutside && !disabled) {\n      callback(ev);\n    }\n  });\n\n  React.useEffect(() => {\n    // Store the current event to avoid triggering handlers immediately\n    // Note this depends on a deprecated but extremely well supported quirk of the web platform\n    // https://github.com/facebook/react/issues/20074\n    let currentEvent = getWindowEvent(window);\n\n    const conditionalHandler = (event: MouseEvent | TouchEvent) => {\n      // Skip if this event is the same as the one running when we added the handlers\n      if (event === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      listener(event);\n    };\n\n    if (!disabled) {\n      // use capture phase because React can update DOM before the event bubbles to the document\n      element?.addEventListener('click', conditionalHandler, true);\n      element?.addEventListener('touchstart', conditionalHandler, true);\n      element?.addEventListener('contextmenu', conditionalHandler, true);\n    }\n\n    // Garbage collect this event after it's no longer useful to avoid memory leaks\n    timeoutId.current = window.setTimeout(() => {\n      currentEvent = undefined;\n    }, 1);\n\n    return () => {\n      element?.removeEventListener('click', conditionalHandler, true);\n      element?.removeEventListener('touchstart', conditionalHandler, true);\n      element?.removeEventListener('contextmenu', conditionalHandler, true);\n\n      clearTimeout(timeoutId.current);\n      currentEvent = undefined;\n    };\n  }, [listener, element, disabled]);\n};\n\nconst getWindowEvent = (target: Node | Window): Event | undefined => {\n  if (target) {\n    if (typeof (target as Window).window === 'object' && (target as Window).window === target) {\n      // eslint-disable-next-line deprecation/deprecation\n      return target.event;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    return (target as Node).ownerDocument?.defaultView?.event ?? undefined;\n  }\n\n  return undefined;\n};\n\nconst FUI_FRAME_EVENT = 'fuiframefocus';\n\n/**\n * Since click events do not propagate past iframes, we use focus to detect if a\n * click has happened inside an iframe, since the only ways of focusing inside an\n * iframe are:\n *   - clicking inside\n *   - tabbing inside\n *\n * Polls the value of `document.activeElement`. If it is an iframe, then dispatch\n * a custom DOM event. When the custom event is received call the provided callback\n *\n * @param enableFrameFocusDispatch - boolean flag to start dispatching events\n * @param targetDocument - the document to dispatch events and set timeouts\n * @param pollDuration  - in milliseconds\n */\nconst useIFrameFocus = (\n  enableFrameFocusDispatch: boolean,\n  targetDocument: Document | undefined,\n  callback: (e: Event) => void,\n  pollDuration: number = 1000,\n) => {\n  const timeoutRef = React.useRef<number>();\n\n  const listener = useEventCallback((e: Event) => {\n    if (callback) {\n      callback(e);\n    }\n  });\n\n  // Adds listener to the custom iframe focus event\n  React.useEffect(() => {\n    if (enableFrameFocusDispatch) {\n      targetDocument?.addEventListener(FUI_FRAME_EVENT, listener, true);\n    }\n    return () => {\n      targetDocument?.removeEventListener(FUI_FRAME_EVENT, listener, true);\n    };\n  }, [targetDocument, enableFrameFocusDispatch, listener]);\n\n  // Starts polling for the active element\n  React.useEffect(() => {\n    if (enableFrameFocusDispatch) {\n      timeoutRef.current = targetDocument?.defaultView?.setInterval(() => {\n        const activeElement = targetDocument?.activeElement;\n        if (activeElement?.tagName === 'IFRAME' || activeElement?.tagName === 'WEBVIEW') {\n          const event = new CustomEvent(FUI_FRAME_EVENT, { bubbles: true });\n          activeElement.dispatchEvent(event);\n        }\n      }, pollDuration);\n    }\n    return () => {\n      targetDocument?.defaultView?.clearTimeout(timeoutRef.current);\n    };\n  }, [targetDocument, enableFrameFocusDispatch, pollDuration]);\n};\n"]}