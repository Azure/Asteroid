{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../../../../packages/react-components/react-utilities/src/compose/types.ts"],"names":[],"mappings":"","sourcesContent":["import * as React from 'react';\n\nexport type SlotRenderFunction<Props> = (\n  Component: React.ElementType<Props>,\n  props: Omit<Props, 'children' | 'as'>,\n) => React.ReactNode;\n\n/**\n * Matches any component's Slots type (such as ButtonSlots).\n *\n * This should ONLY be used in type templates as in `extends SlotPropsRecord`;\n * it shouldn't be used as a component's Slots type.\n */\nexport type SlotPropsRecord = Record<string, UnknownSlotProps | SlotShorthandValue | null | undefined>;\n\n/**\n * The shorthand value of a slot allows specifying its child\n */\nexport type SlotShorthandValue = React.ReactChild | React.ReactNode[] | React.ReactPortal;\n\n/**\n * Matches any slot props type.\n *\n * This should ONLY be used in type templates as in `extends UnknownSlotProps`;\n * it shouldn't be used as the type of a slot.\n */\nexport type UnknownSlotProps = Pick<React.HTMLAttributes<HTMLElement>, 'children' | 'className' | 'style'> & {\n  as?: keyof JSX.IntrinsicElements;\n};\n\n/**\n * Helper type for {@link Slot}. Adds shorthand types that are assignable to the slot's `children`.\n */\ntype WithSlotShorthandValue<Props extends { children?: unknown }> =\n  | Props\n  | Extract<SlotShorthandValue, Props['children']>;\n\n/**\n * Helper type for {@link Slot}. Takes the props we want to support for a slot and adds the ability for `children`\n * to be a render function that takes those props.\n */\ntype WithSlotRenderFunction<Props extends { children?: unknown }> = Props & {\n  children?: Props['children'] | SlotRenderFunction<Props>;\n};\n\n/**\n * HTML element types that are not allowed to have children.\n *\n * Reference: https://developer.mozilla.org/en-US/docs/Glossary/Empty_element\n */\ntype EmptyIntrisicElements =\n  | 'area'\n  | 'base'\n  | 'br'\n  | 'col'\n  | 'embed'\n  | 'hr'\n  | 'img'\n  | 'input'\n  | 'link'\n  | 'meta'\n  | 'param'\n  | 'source'\n  | 'track'\n  | 'wbr';\n\n/**\n * Helper type for {@link Slot}. Modifies `JSX.IntrinsicElements[Type]`:\n * * Removes legacy string ref.\n * * Disallows children for empty tags like 'img'.\n */\ntype IntrisicElementProps<Type extends keyof JSX.IntrinsicElements> = React.PropsWithRef<JSX.IntrinsicElements[Type]> &\n  (Type extends EmptyIntrisicElements ? { children?: never } : {});\n\n/**\n * The props type and shorthand value for a slot. Type is either a single intrinsic element like `'div'`,\n * or a component like `typeof Button`.\n *\n * If a slot needs to support multiple intrinsic element types, use the `AlternateAs` param (see examples below).\n *\n * By default, slots can be set to `null` to prevent them from being rendered. If a slot must always be rendered,\n * wrap with `NonNullable` (see examples below).\n *\n * @example\n * ```\n * // Intrinsic element examples:\n * Slot<'div'> // Slot is always div\n * Slot<'button', 'a'> // Defaults to button, but allows as=\"a\" with anchor-specific props\n * Slot<'span', 'div' | 'pre'> // Defaults to span, but allows as=\"div\" or as=\"pre\"\n * NonNullable<Slot<'div'>> // Slot that will always be rendered (can't be set to null by the user)\n *\n * // Component examples:\n * Slot<typeof Button> // Slot is always a Button, and accepts all of Button's Props\n * NonNullable<Slot<typeof Label>> // Slot is a Label and will always be rendered (can't be set to null by the user)\n * ```\n */\nexport type Slot<\n  Type extends keyof JSX.IntrinsicElements | React.ComponentType | React.VoidFunctionComponent | UnknownSlotProps,\n  AlternateAs extends keyof JSX.IntrinsicElements = never\n> = IsSingleton<Extract<Type, string>> extends true\n  ?\n      | WithSlotShorthandValue<\n          Type extends keyof JSX.IntrinsicElements // Intrinsic elements like `div`\n            ? { as?: Type } & WithSlotRenderFunction<IntrisicElementProps<Type>>\n            : Type extends React.ComponentType<infer Props> // Component types like `typeof Button`\n            ? WithSlotRenderFunction<Props>\n            : Type // Props types like `ButtonProps`\n        >\n      | {\n          [As in AlternateAs]: { as: As } & WithSlotRenderFunction<IntrisicElementProps<As>>;\n        }[AlternateAs]\n      | null\n  : 'Error: First parameter to Slot must not be not a union of types. See documentation of Slot type.';\n\n/**\n * Evaluates to true if the given type contains exactly one string, or false if it is a union of strings.\n *\n * ```\n * IsSingleton<'a'> // true\n * IsSingleton<'a' | 'b' | 'c'> // false\n * ```\n */\nexport type IsSingleton<T extends string> = { [K in T]: Exclude<T, K> extends never ? true : false }[T];\n\n/**\n * Helper type for inferring the type of the as prop from a Props type.\n *\n * For example:\n * ```\n * type Example<T> = T extends AsIntrinsicElement<infer As> ? As : never;\n * ```\n */\nexport type AsIntrinsicElement<As extends keyof JSX.IntrinsicElements> = { as?: As };\n\n/**\n * Converts a union type (`A | B | C`) to an intersection type (`A & B & C`)\n */\nexport type UnionToIntersection<U> = (U extends unknown ? (x: U) => U : never) extends (x: infer I) => U ? I : never;\n\n/**\n * Removes the 'ref' prop from the given Props type, leaving unions intact (such as the discriminated union created by\n * IntrinsicSlotProps). This allows IntrinsicSlotProps to be used with React.forwardRef.\n *\n * The conditional \"extends unknown\" (always true) exploits a quirk in the way TypeScript handles conditional\n * types, to prevent unions from being expanded.\n */\nexport type PropsWithoutRef<P> = 'ref' extends keyof P ? (P extends unknown ? Omit<P, 'ref'> : P) : P;\n\n/**\n * Removes SlotShorthandValue and null from the slot type, extracting just the slot's Props object.\n */\nexport type ExtractSlotProps<S> = Exclude<S, SlotShorthandValue | null | undefined>;\n\n/**\n * Defines the Props type for a component given its slots and the definition of which one is the primary slot,\n * defaulting to root if one is not provided.\n */\nexport type ComponentProps<Slots extends SlotPropsRecord, Primary extends keyof Slots = 'root'> =\n  // Include a prop for each slot (see note below about the Omit)\n  Omit<Slots, Primary & 'root'> &\n    // Include all of the props of the primary slot inline in the component's props\n    PropsWithoutRef<ExtractSlotProps<Slots[Primary]>>;\n\n// Note: the `Omit<Slots, Primary & 'root'>` above is a little tricky. Here's what it's doing:\n// * If the Primary slot is 'root', then omit the `root` slot prop.\n// * Otherwise, don't omit any props: include *both* the Primary and `root` props.\n//   We need both props to allow the user to specify native props for either slot because the `root` slot is\n//   special and always gets className and style props, per RFC https://github.com/microsoft/fluentui/pull/18983\n\n/**\n * If type T includes `null`, remove it and add `undefined` instead.\n */\nexport type ReplaceNullWithUndefined<T> = T extends null ? Exclude<T, null> | undefined : T;\n\n/**\n * Defines the State object of a component given its slots.\n */\nexport type ComponentState<Slots extends SlotPropsRecord> = {\n  components: {\n    [Key in keyof Slots]-?:\n      | React.ComponentType<ExtractSlotProps<Slots[Key]>>\n      | (ExtractSlotProps<Slots[Key]> extends AsIntrinsicElement<infer As> ? As : keyof JSX.IntrinsicElements);\n  };\n} & {\n  // Include a prop for each slot, with the shorthand resolved to a props object\n  // The root slot can never be null, so also exclude null from it\n  [Key in keyof Slots]: ReplaceNullWithUndefined<\n    Exclude<Slots[Key], SlotShorthandValue | (Key extends 'root' ? null : never)>\n  >;\n};\n\n/**\n * This is part of a hack to infer the element type from a native element *props* type.\n * The only place the original element is found in a native props type (at least that's workable\n * for inference) is in the event handlers, so some of the helper types use this event handler\n * name to infer the original element type.\n *\n * Notes:\n * - Using an extremely obscure event handler reduces the likelihood that its signature will be\n *   modified in any component's props.\n * - Inferring based on a single prop name instead of a larger type like `DOMAttributes<T>` should be\n *   less expensive for typescript to evaluate and is less likely to result in type expansion in .d.ts.\n */\ntype ObscureEventName = 'onLostPointerCaptureCapture';\n\n/**\n * Return type for `React.forwardRef`, including inference of the proper typing for the ref.\n */\nexport type ForwardRefComponent<Props> = ObscureEventName extends keyof Props\n  ? Required<Props>[ObscureEventName] extends React.PointerEventHandler<infer Element>\n    ? React.ForwardRefExoticComponent<Props & React.RefAttributes<Element>>\n    : never\n  : never;\n// A definition like this would also work, but typescript is more likely to unnecessarily expand\n// the props type with this version (and it's likely much more expensive to evaluate)\n// export type ForwardRefComponent<Props> = Props extends React.DOMAttributes<infer Element>\n//   ? React.ForwardRefExoticComponent<Props> & React.RefAttributes<Element>\n//   : never;\n\n/**\n * Helper type to correctly define the slot class names object.\n */\nexport type SlotClassNames<Slots> = {\n  [SlotName in keyof Slots]-?: string;\n};\n"]}