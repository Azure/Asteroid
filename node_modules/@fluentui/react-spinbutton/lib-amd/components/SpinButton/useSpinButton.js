define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/keyboard-keys", "../../utils/index", "@fluentui/react-icons"], function (require, exports, tslib_1, React, react_utilities_1, Keys, index_1, react_icons_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSpinButton_unstable = void 0;
    var DEFAULT_SPIN_DELAY_MS = 150;
    var MIN_SPIN_DELAY_MS = 80;
    var MAX_SPIN_TIME_MS = 1000;
    // This is here to give an ease the mouse held down case.
    // Exact easing it to be defined. Once it is we'll likely
    // pull this out into a util function in the SpinButton package.
    var lerp = function (start, end, percent) { return start + (end - start) * percent; };
    /**
     * Create the state required to render SpinButton.
     *
     * The returned state can be modified with hooks such as useSpinButtonStyles_unstable,
     * before being passed to renderSpinButton_unstable.
     *
     * @param props - props from this instance of SpinButton
     * @param ref - reference to root HTMLElement of SpinButton
     */
    var useSpinButton_unstable = function (props, ref) {
        var _a;
        var nativeProps = react_utilities_1.getPartitionedNativeProps({
            props: props,
            primarySlotTagName: 'input',
            excludedPropNames: ['defaultValue', 'max', 'min', 'onChange', 'size', 'value'],
        });
        var value = props.value, displayValue = props.displayValue, defaultValue = props.defaultValue, min = props.min, max = props.max, _b = props.step, step = _b === void 0 ? 1 : _b, _c = props.stepPage, stepPage = _c === void 0 ? 1 : _c, precisionFromProps = props.precision, onChange = props.onChange, _d = props.size, size = _d === void 0 ? 'medium' : _d, _e = props.appearance, appearance = _e === void 0 ? 'outline' : _e, root = props.root, input = props.input, incrementButton = props.incrementButton, decrementButton = props.decrementButton;
        var precision = React.useMemo(function () {
            return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(index_1.calculatePrecision(step), 0);
        }, [precisionFromProps, step]);
        var _f = react_utilities_1.useControllableState({
            state: value,
            defaultState: defaultValue,
            initialState: 0,
        }), currentValue = _f[0], setCurrentValue = _f[1];
        var isControlled = value !== undefined;
        var _g = React.useState(undefined), textValue = _g[0], setTextValue = _g[1];
        var _h = React.useState('rest'), keyboardSpinState = _h[0], setKeyboardSpinState = _h[1];
        var internalState = React.useRef({
            value: currentValue,
            spinState: 'rest',
            spinTime: 0,
            spinDelay: DEFAULT_SPIN_DELAY_MS,
            atBound: currentValue !== null ? index_1.getBound(index_1.precisionRound(currentValue, precision), min, max) : 'none',
        });
        var _j = react_utilities_1.useTimeout(), setStepTimeout = _j[0], clearStepTimeout = _j[1];
        var stepValue = function (e, direction, startFrom) {
            var startValue = internalState.current.value;
            if (startFrom) {
                var num = parseFloat(startFrom);
                if (!isNaN(num)) {
                    startValue = num;
                }
            }
            var val = startValue;
            var dir = direction === 'up' || direction === 'upPage' ? 1 : -1;
            var stepSize = direction === 'upPage' || direction === 'downPage' ? stepPage : step;
            if (val === null) {
                var stepStart = min === undefined ? 0 : min;
                var nullStep = index_1.clamp(stepStart + stepSize * dir, min, max);
                commit(e, nullStep);
                return;
            }
            var newValue = val + stepSize * dir;
            if (!Number.isNaN(newValue)) {
                newValue = index_1.clamp(newValue, min, max);
            }
            commit(e, newValue);
            if (internalState.current.spinState !== 'rest') {
                setStepTimeout(function () {
                    // Ease the step speed a bit
                    internalState.current.spinTime += internalState.current.spinDelay;
                    internalState.current.spinDelay = lerp(DEFAULT_SPIN_DELAY_MS, MIN_SPIN_DELAY_MS, internalState.current.spinTime / MAX_SPIN_TIME_MS);
                    stepValue(e, direction);
                }, internalState.current.spinDelay);
            }
        };
        var handleInputChange = function (e) {
            if (!internalState.current.previousTextValue) {
                internalState.current.previousTextValue = textValue;
            }
            var newValue = e.target.value;
            setTextValue(newValue);
        };
        var handleIncrementMouseDown = function (e) {
            internalState.current.spinState = 'up';
            stepValue(e, 'up');
        };
        var handleDecrementMouseDown = function (e) {
            internalState.current.spinState = 'down';
            stepValue(e, 'down');
        };
        var handleStepMouseUpOrLeave = function (e) {
            clearStepTimeout();
            internalState.current.spinState = 'rest';
            internalState.current.spinDelay = DEFAULT_SPIN_DELAY_MS;
            internalState.current.spinTime = 0;
        };
        var handleBlur = function (e) {
            commit(e, currentValue, textValue);
            internalState.current.previousTextValue = undefined;
        };
        var handleKeyDown = function (e) {
            var nextKeyboardSpinState = 'rest';
            if (e.key === Keys.ArrowUp) {
                stepValue(e, 'up', textValue);
                nextKeyboardSpinState = 'up';
            }
            else if (e.key === Keys.ArrowDown) {
                stepValue(e, 'down', textValue);
                nextKeyboardSpinState = 'down';
            }
            else if (e.key === Keys.PageUp) {
                e.preventDefault();
                stepValue(e, 'upPage', textValue);
                nextKeyboardSpinState = 'up';
            }
            else if (e.key === Keys.PageDown) {
                e.preventDefault();
                stepValue(e, 'downPage', textValue);
                nextKeyboardSpinState = 'down';
            }
            else if (!e.shiftKey && e.key === Keys.Home && min !== undefined) {
                commit(e, min);
                nextKeyboardSpinState = 'down';
            }
            else if (!e.shiftKey && e.key === Keys.End && max !== undefined) {
                commit(e, max);
                nextKeyboardSpinState = 'up';
            }
            else if (e.key === Keys.Enter) {
                commit(e, currentValue, textValue);
                internalState.current.previousTextValue = undefined;
            }
            else if (e.key === Keys.Escape) {
                if (internalState.current.previousTextValue) {
                    setTextValue(undefined);
                    internalState.current.previousTextValue = undefined;
                }
            }
            if (keyboardSpinState !== nextKeyboardSpinState) {
                setKeyboardSpinState(nextKeyboardSpinState);
            }
        };
        var handleKeyUp = function (e) {
            if (keyboardSpinState !== 'rest') {
                setKeyboardSpinState('rest');
                internalState.current.spinState = 'rest';
            }
        };
        var commit = function (e, newValue, newDisplayValue) {
            var valueChanged = newValue !== undefined && currentValue !== newValue;
            var displayValueChanged = newDisplayValue !== undefined &&
                internalState.current.previousTextValue !== undefined &&
                internalState.current.previousTextValue !== newDisplayValue;
            var roundedValue;
            if (valueChanged) {
                roundedValue = index_1.precisionRound(newValue, precision);
                setCurrentValue(roundedValue);
            }
            else if (displayValueChanged && !isControlled) {
                var nextValue = parseFloat(newDisplayValue);
                if (!isNaN(nextValue)) {
                    setCurrentValue(index_1.precisionRound(nextValue, precision));
                }
            }
            if (valueChanged || displayValueChanged) {
                onChange === null || onChange === void 0 ? void 0 : onChange(e, { value: roundedValue, displayValue: newDisplayValue });
            }
            setTextValue(undefined);
        };
        var state = {
            size: size,
            appearance: appearance,
            spinState: keyboardSpinState,
            atBound: internalState.current.atBound,
            components: {
                root: 'span',
                input: 'input',
                incrementButton: 'button',
                decrementButton: 'button',
            },
            root: react_utilities_1.resolveShorthand(root, {
                required: true,
                defaultProps: nativeProps.root,
            }),
            input: react_utilities_1.resolveShorthand(input, {
                required: true,
                defaultProps: tslib_1.__assign({ ref: ref, autoComplete: 'off', role: 'spinbutton', appearance: appearance, type: 'text' }, nativeProps.primary),
            }),
            incrementButton: react_utilities_1.resolveShorthand(incrementButton, {
                required: true,
                defaultProps: {
                    tabIndex: -1,
                    children: React.createElement(react_icons_1.ChevronUp16Regular, null),
                    disabled: nativeProps.primary.disabled,
                    'aria-label': 'Increment value',
                    type: 'button',
                },
            }),
            decrementButton: react_utilities_1.resolveShorthand(decrementButton, {
                required: true,
                defaultProps: {
                    tabIndex: -1,
                    children: React.createElement(react_icons_1.ChevronDown16Regular, null),
                    disabled: nativeProps.primary.disabled,
                    'aria-label': 'Decrement value',
                    type: 'button',
                },
            }),
        };
        var valueToDisplay;
        if (textValue !== undefined) {
            valueToDisplay = textValue;
        }
        else if (value === null || currentValue === null) {
            valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : '';
            internalState.current.value = null;
            internalState.current.atBound = 'none';
        }
        else {
            var roundedValue = index_1.precisionRound(currentValue, precision);
            internalState.current.value = roundedValue;
            internalState.current.atBound = index_1.getBound(roundedValue, min, max);
            if (isControlled) {
                valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : String(roundedValue);
            }
            else {
                valueToDisplay = String(roundedValue);
            }
        }
        state.input.value = valueToDisplay;
        state.input['aria-valuemin'] = min;
        state.input['aria-valuemax'] = max;
        state.input['aria-valuenow'] = currentValue !== null && currentValue !== void 0 ? currentValue : undefined;
        state.input['aria-valuetext'] = (_a = state.input['aria-valuetext']) !== null && _a !== void 0 ? _a : ((value !== undefined && displayValue) || undefined);
        state.input.onChange = react_utilities_1.mergeCallbacks(state.input.onChange, handleInputChange);
        state.input.onBlur = react_utilities_1.mergeCallbacks(state.input.onBlur, handleBlur);
        state.input.onKeyDown = react_utilities_1.mergeCallbacks(state.input.onKeyDown, handleKeyDown);
        state.input.onKeyUp = react_utilities_1.mergeCallbacks(state.input.onKeyUp, handleKeyUp);
        state.incrementButton.onMouseDown = react_utilities_1.mergeCallbacks(handleIncrementMouseDown, state.incrementButton.onMouseDown);
        state.incrementButton.onMouseUp = react_utilities_1.mergeCallbacks(state.incrementButton.onMouseUp, handleStepMouseUpOrLeave);
        state.incrementButton.onMouseLeave = react_utilities_1.mergeCallbacks(state.incrementButton.onMouseLeave, handleStepMouseUpOrLeave);
        state.decrementButton.onMouseDown = react_utilities_1.mergeCallbacks(handleDecrementMouseDown, state.decrementButton.onMouseDown);
        state.decrementButton.onMouseUp = react_utilities_1.mergeCallbacks(state.decrementButton.onMouseUp, handleStepMouseUpOrLeave);
        state.decrementButton.onMouseLeave = react_utilities_1.mergeCallbacks(state.decrementButton.onMouseLeave, handleStepMouseUpOrLeave);
        return state;
    };
    exports.useSpinButton_unstable = useSpinButton_unstable;
});
//# sourceMappingURL=useSpinButton.js.map