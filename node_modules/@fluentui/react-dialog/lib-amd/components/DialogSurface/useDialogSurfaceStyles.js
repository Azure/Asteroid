define(["require", "exports", "tslib", "@griffel/react", "@fluentui/react-theme", "@fluentui/react-tabster", "../../contexts"], function (require, exports, tslib_1, react_1, react_theme_1, react_tabster_1, contexts_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDialogSurfaceStyles_unstable = exports.dialogSurfaceClassNames = void 0;
    exports.dialogSurfaceClassNames = {
        root: 'fui-DialogSurface',
        backdrop: 'fui-DialogSurface__backdrop',
    };
    /**
     * Styles for the root slot
     */
    var useStyles = react_1.makeStyles({
        focusOutline: react_tabster_1.createFocusOutlineStyle(),
        root: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ display: 'block', userSelect: 'unset', visibility: 'unset' }, react_1.shorthands.inset(0)), react_1.shorthands.padding(0)), react_1.shorthands.padding(contexts_1.SURFACE_PADDING)), react_1.shorthands.margin('auto')), react_1.shorthands.borderStyle('none')), react_1.shorthands.overflow('unset')), { '&::backdrop': {
                backgroundColor: 'rgba(0, 0, 0, 0.4)',
            }, position: 'fixed', width: '100%', height: 'fit-content', maxWidth: '600px', maxHeight: '100vh', boxSizing: 'border-box', boxShadow: react_theme_1.tokens.shadow64, backgroundColor: react_theme_1.tokens.colorNeutralBackground1, color: react_theme_1.tokens.colorNeutralForeground1 }), react_1.shorthands.border(contexts_1.SURFACE_BORDER_WIDTH, 'solid', react_theme_1.tokens.colorTransparentStroke)), react_1.shorthands.borderRadius(contexts_1.SURFACE_BORDER_RADIUS)), (_a = {}, _a[contexts_1.MEDIA_QUERY_BREAKPOINT_SELECTOR] = {
            maxWidth: '100vw',
        }, _a)),
        backdrop: tslib_1.__assign({ position: 'fixed', backgroundColor: 'rgba(0, 0, 0, 0.4)' }, react_1.shorthands.inset('0px')),
        nestedDialogBackdrop: {
            backgroundColor: 'transparent',
        },
        nestedNativeDialogBackdrop: {
            '&::backdrop': {
                backgroundColor: 'transparent',
            },
        },
    });
    /**
     * Apply styling to the DialogSurface slots based on the state
     */
    var useDialogSurfaceStyles_unstable = function (state) {
        var styles = useStyles();
        var isNestedDialog = contexts_1.useDialogContext_unstable(function (ctx) { return ctx.isNestedDialog; });
        state.root.className = react_1.mergeClasses(exports.dialogSurfaceClassNames.root, styles.root, styles.focusOutline, isNestedDialog && styles.nestedNativeDialogBackdrop, state.root.className);
        if (state.backdrop) {
            state.backdrop.className = react_1.mergeClasses(exports.dialogSurfaceClassNames.backdrop, styles.backdrop, isNestedDialog && styles.nestedDialogBackdrop, state.backdrop.className);
        }
        return state;
    };
    exports.useDialogSurfaceStyles_unstable = useDialogSurfaceStyles_unstable;
});
//# sourceMappingURL=useDialogSurfaceStyles.js.map