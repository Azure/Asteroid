"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCombobox_unstable = void 0;

const React = /*#__PURE__*/require("react");

const react_icons_1 = /*#__PURE__*/require("@fluentui/react-icons");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const dropdownKeyActions_1 = /*#__PURE__*/require("../../utils/dropdownKeyActions");

const useComboboxBaseState_1 = /*#__PURE__*/require("../../utils/useComboboxBaseState");

const useComboboxPopup_1 = /*#__PURE__*/require("../../utils/useComboboxPopup");

const useTriggerListboxSlots_1 = /*#__PURE__*/require("../../utils/useTriggerListboxSlots");

const Listbox_1 = /*#__PURE__*/require("../Listbox/Listbox");
/**
 * Create the state required to render Combobox.
 *
 * The returned state can be modified with hooks such as useComboboxStyles_unstable,
 * before being passed to renderCombobox_unstable.
 *
 * @param props - props from this instance of Combobox
 * @param ref - reference to root HTMLElement of Combobox
 */


const useCombobox_unstable = (props, ref) => {
  var _a;

  const baseState = useComboboxBaseState_1.useComboboxBaseState({ ...props,
    editable: true
  });
  const {
    activeOption,
    clearSelection,
    getIndexOfId,
    getOptionsMatchingText,
    hasFocus,
    open,
    selectOption,
    selectedOptions,
    setActiveOption,
    setFocusVisible,
    setOpen,
    setValue,
    value
  } = baseState;
  const {
    freeform,
    multiselect
  } = props;
  const {
    primary: triggerNativeProps,
    root: rootNativeProps
  } = react_utilities_1.getPartitionedNativeProps({
    props,
    primarySlotTagName: 'input',
    excludedPropNames: ['children', 'size']
  });
  const rootRef = React.useRef(null);
  const triggerRef = React.useRef(null); // calculate listbox width style based on trigger width

  const [popupWidth, setPopupWidth] = React.useState();
  React.useEffect(() => {
    var _a;

    const width = open ? `${(_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth}px` : undefined;
    setPopupWidth(width);
  }, [open]); // set active option and selection based on typing

  const getOptionFromInput = inputValue => {
    var _a;

    const searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();

    if (!searchString || searchString.length === 0) {
      return;
    }

    const matcher = optionText => optionText.toLowerCase().indexOf(searchString) === 0;

    const matches = getOptionsMatchingText(matcher); // return first matching option after the current active option, looping back to the top

    if (matches.length > 1 && activeOption) {
      const startIndex = getIndexOfId(activeOption.id);
      const nextMatch = matches.find(option => getIndexOfId(option.id) >= startIndex);
      return nextMatch !== null && nextMatch !== void 0 ? nextMatch : matches[0];
    }

    return (_a = matches[0]) !== null && _a !== void 0 ? _a : undefined;
  };
  /* Handle typed input */
  // reset any typed value when an option is selected


  baseState.selectOption = (ev, option) => {
    setValue(undefined);
    selectOption(ev, option);
  };

  const onTriggerBlur = ev => {
    // handle selection and updating value if freeform is false
    if (!baseState.open && !freeform) {
      // select matching option, if the value fully matches
      if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.value.toLowerCase())) {
        baseState.selectOption(ev, activeOption);
      } // reset typed value when the input loses focus while collapsed, unless freeform is true


      setValue(undefined);
    }
  };

  baseState.setOpen = (ev, newState) => {
    if (!newState && !freeform) {
      setValue(undefined);
    }

    setOpen(ev, newState);
  }; // update value and active option based on input


  const onTriggerChange = ev => {
    const inputValue = ev.target.value; // update uncontrolled value

    baseState.setValue(inputValue); // handle updating active option based on input

    const matchingOption = getOptionFromInput(inputValue);
    setActiveOption(matchingOption);
    setFocusVisible(true); // clear selection for single-select if the input value no longer matches the selection

    if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || selectedOptions[0].indexOf(inputValue) !== 0)) {
      clearSelection(ev);
    }
  }; // open Combobox when typing


  const onTriggerKeyDown = ev => {
    if (!open && dropdownKeyActions_1.getDropdownActionFromKey(ev) === 'Type') {
      setOpen(ev, true);
    }
  }; // resolve input and listbox slot props


  let triggerSlot;
  let listboxSlot;
  triggerSlot = react_utilities_1.resolveShorthand(props.input, {
    required: true,
    defaultProps: {
      ref: react_utilities_1.useMergedRefs((_a = props.input) === null || _a === void 0 ? void 0 : _a.ref, triggerRef),
      type: 'text',
      value: value !== null && value !== void 0 ? value : '',
      ...triggerNativeProps
    }
  });
  triggerSlot.onChange = react_utilities_1.mergeCallbacks(triggerSlot.onChange, onTriggerChange);
  triggerSlot.onBlur = react_utilities_1.mergeCallbacks(triggerSlot.onBlur, onTriggerBlur);
  triggerSlot.onKeyDown = react_utilities_1.mergeCallbacks(triggerSlot.onKeyDown, onTriggerKeyDown); // only resolve listbox slot if needed

  listboxSlot = open || hasFocus ? react_utilities_1.resolveShorthand(props.listbox, {
    required: true,
    defaultProps: {
      children: props.children,
      style: {
        width: popupWidth
      }
    }
  }) : undefined;
  [triggerSlot, listboxSlot] = useComboboxPopup_1.useComboboxPopup(props, triggerSlot, listboxSlot);
  [triggerSlot, listboxSlot] = useTriggerListboxSlots_1.useTriggerListboxSlots(props, baseState, ref, triggerSlot, listboxSlot);
  const state = {
    components: {
      root: 'div',
      input: 'input',
      expandIcon: 'span',
      listbox: Listbox_1.Listbox
    },
    root: react_utilities_1.resolveShorthand(props.root, {
      required: true,
      defaultProps: { ...rootNativeProps
      }
    }),
    input: triggerSlot,
    listbox: listboxSlot,
    expandIcon: react_utilities_1.resolveShorthand(props.expandIcon, {
      required: true,
      defaultProps: {
        children: React.createElement(react_icons_1.ChevronDownRegular, null)
      }
    }),
    ...baseState,
    setOpen
  };
  state.root.ref = react_utilities_1.useMergedRefs(state.root.ref, rootRef);
  /* handle open/close + focus change when clicking expandIcon */

  const {
    onMouseDown: onIconMouseDown,
    onClick: onIconClick
  } = state.expandIcon || {};
  const onExpandIconMouseDown = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(onIconMouseDown, () => {
    // do not dismiss on blur when closing via clicking the icon
    if (open) {
      baseState.ignoreNextBlur.current = true;
    }
  }));
  const onExpandIconClick = react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(onIconClick, event => {
    var _a; // open and set focus


    state.setOpen(event, !state.open);
    (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
  }));

  if (state.expandIcon) {
    state.expandIcon.onMouseDown = onExpandIconMouseDown;
    state.expandIcon.onClick = onExpandIconClick;
  }

  return state;
};

exports.useCombobox_unstable = useCombobox_unstable;
//# sourceMappingURL=useCombobox.js.map