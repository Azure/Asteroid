import * as React from 'react';
import { isInteractiveHTMLElement, useEventCallback, resolveShorthand } from '@fluentui/react-utilities';
import { Space } from '@fluentui/keyboard-keys';
import { useTableRow_unstable } from '../TableRow/useTableRow';
import { useDataGridContext_unstable } from '../../contexts/dataGridContext';
import { ColumnIdContextProvider } from '../../contexts/columnIdContext';
import { DataGridSelectionCell } from '../DataGridSelectionCell/DataGridSelectionCell';
import { useRowIdContext } from '../../contexts/rowIdContext';
import { useIsInTableHeader } from '../../contexts/tableHeaderContext';
/**
 * Create the state required to render DataGridRow.
 *
 * The returned state can be modified with hooks such as useDataGridRowStyles_unstable,
 * before being passed to renderDataGridRow_unstable.
 *
 * @param props - props from this instance of DataGridRow
 * @param ref - reference to root HTMLElement of DataGridRow
 */

export const useDataGridRow_unstable = (props, ref) => {
  const rowId = useRowIdContext();
  const isHeader = useIsInTableHeader();
  const columnDefs = useDataGridContext_unstable(ctx => ctx.columns);
  const selectable = useDataGridContext_unstable(ctx => ctx.selectableRows);
  const selected = useDataGridContext_unstable(ctx => ctx.selection.isRowSelected(rowId));
  const tabbable = useDataGridContext_unstable(ctx => ctx.focusMode === 'row_unstable');
  const appearance = useDataGridContext_unstable(ctx => {
    if (!isHeader && selectable && ctx.selection.isRowSelected(rowId)) {
      return ctx.selectionAppearance;
    }

    return 'none';
  });
  const toggleRow = useDataGridContext_unstable(ctx => ctx.selection.toggleRow);
  const cellRenderFunction = props.children;
  const cells = columnDefs.map(columnDef => {
    return /*#__PURE__*/React.createElement(ColumnIdContextProvider, {
      value: columnDef.columnId,
      key: columnDef.columnId
    }, cellRenderFunction(columnDef));
  });
  const onClick = useEventCallback(e => {
    var _a;

    if (selectable && !isHeader) {
      toggleRow(e, rowId);
    }

    (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props, e);
  });
  const onKeyDown = useEventCallback(e => {
    var _a;

    if (selectable && !isHeader && e.key === Space && !isInteractiveHTMLElement(e.target)) {
      // stop scrolling
      e.preventDefault();
      toggleRow(e, rowId);
    }

    (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
  });
  const baseState = useTableRow_unstable({
    appearance,
    'aria-selected': selectable ? selected : undefined,
    ...props,
    onClick,
    onKeyDown,
    children: cells,
    as: 'div',
    tabIndex: tabbable && !isHeader ? 0 : undefined
  }, ref);
  return { ...baseState,
    components: { ...baseState.components,
      selectionCell: DataGridSelectionCell
    },
    selectionCell: resolveShorthand(props.selectionCell, {
      required: selectable
    })
  };
};
//# sourceMappingURL=useDataGridRow.js.map