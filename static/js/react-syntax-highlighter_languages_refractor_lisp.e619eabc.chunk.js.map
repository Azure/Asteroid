{"version":3,"file":"static/js/react-syntax-highlighter_languages_refractor_lisp.e619eabc.chunk.js","mappings":"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","sources":["../node_modules/refractor/lang/lisp.js"],"sourcesContent":["'use strict'\r\n\r\nmodule.exports = lisp\r\nlisp.displayName = 'lisp'\r\nlisp.aliases = []\r\nfunction lisp(Prism) {\r\n  ;(function(Prism) {\r\n    // Functions to construct regular expressions\r\n    // simple form\r\n    // e.g. (interactive ... or (interactive)\r\n    function simple_form(name) {\r\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])')\r\n    } // booleans and numbers\r\n    function primitive(pattern) {\r\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])')\r\n    } // Patterns in regular expressions\r\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\r\n    // & and : are excluded as they are usually used for special purposes\r\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+' // symbol starting with & used in function arguments\r\n    var marker = '&' + symbol // Open parenthesis for look-behind\r\n    var par = '(\\\\()'\r\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\r\n    var space = '(?=\\\\s)'\r\n    var language = {\r\n      // Three or four semicolons are considered a heading.\r\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\r\n      heading: {\r\n        pattern: /;;;.*/,\r\n        alias: ['comment', 'title']\r\n      },\r\n      comment: /;.*/,\r\n      string: {\r\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\r\n        greedy: true,\r\n        inside: {\r\n          argument: /[-A-Z]+(?=[.,\\s])/,\r\n          symbol: RegExp('`' + symbol + \"'\")\r\n        }\r\n      },\r\n      'quoted-symbol': {\r\n        pattern: RegExp(\"#?'\" + symbol),\r\n        alias: ['variable', 'symbol']\r\n      },\r\n      'lisp-property': {\r\n        pattern: RegExp(':' + symbol),\r\n        alias: 'property'\r\n      },\r\n      splice: {\r\n        pattern: RegExp(',@?' + symbol),\r\n        alias: ['symbol', 'variable']\r\n      },\r\n      keyword: [\r\n        {\r\n          pattern: RegExp(\r\n            par +\r\n              '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\r\n              space\r\n          ),\r\n          lookbehind: true\r\n        },\r\n        {\r\n          pattern: RegExp(\r\n            par +\r\n              '(?:for|do|collect|return|finally|append|concat|in|by)' +\r\n              space\r\n          ),\r\n          lookbehind: true\r\n        }\r\n      ],\r\n      declare: {\r\n        pattern: simple_form('declare'),\r\n        lookbehind: true,\r\n        alias: 'keyword'\r\n      },\r\n      interactive: {\r\n        pattern: simple_form('interactive'),\r\n        lookbehind: true,\r\n        alias: 'keyword'\r\n      },\r\n      boolean: {\r\n        pattern: primitive('(?:t|nil)'),\r\n        lookbehind: true\r\n      },\r\n      number: {\r\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\r\n        lookbehind: true\r\n      },\r\n      defvar: {\r\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\r\n        lookbehind: true,\r\n        inside: {\r\n          keyword: /^def[a-z]+/,\r\n          variable: RegExp(symbol)\r\n        }\r\n      },\r\n      defun: {\r\n        pattern: RegExp(\r\n          par +\r\n            '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\r\n            symbol +\r\n            '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\r\n        ),\r\n        lookbehind: true,\r\n        inside: {\r\n          keyword: /^(?:cl-)?def\\S+/,\r\n          // See below, this property needs to be defined later so that it can\r\n          // reference the language object.\r\n          arguments: null,\r\n          function: {\r\n            pattern: RegExp('(^\\\\s)' + symbol),\r\n            lookbehind: true\r\n          },\r\n          punctuation: /[()]/\r\n        }\r\n      },\r\n      lambda: {\r\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\r\n        lookbehind: true,\r\n        inside: {\r\n          keyword: /^lambda/,\r\n          // See below, this property needs to be defined later so that it can\r\n          // reference the language object.\r\n          arguments: null,\r\n          punctuation: /[()]/\r\n        }\r\n      },\r\n      car: {\r\n        pattern: RegExp(par + symbol),\r\n        lookbehind: true\r\n      },\r\n      punctuation: [\r\n        // open paren, brackets, and close paren\r\n        /(['`,]?\\(|[)\\[\\]])/, // cons\r\n        {\r\n          pattern: /(\\s)\\.(?=\\s)/,\r\n          lookbehind: true\r\n        }\r\n      ]\r\n    }\r\n    var arg = {\r\n      'lisp-marker': RegExp(marker),\r\n      rest: {\r\n        argument: {\r\n          pattern: RegExp(symbol),\r\n          alias: 'variable'\r\n        },\r\n        varform: {\r\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\r\n          lookbehind: true,\r\n          inside: {\r\n            string: language.string,\r\n            boolean: language.boolean,\r\n            number: language.number,\r\n            symbol: language.symbol,\r\n            punctuation: /[()]/\r\n          }\r\n        }\r\n      }\r\n    }\r\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\r\n    var arglist = {\r\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\r\n      lookbehind: true,\r\n      inside: {\r\n        'rest-vars': {\r\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\r\n          inside: arg\r\n        },\r\n        'other-marker-vars': {\r\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\r\n          inside: arg\r\n        },\r\n        keys: {\r\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\r\n          inside: arg\r\n        },\r\n        argument: {\r\n          pattern: RegExp(symbol),\r\n          alias: 'variable'\r\n        },\r\n        punctuation: /[()]/\r\n      }\r\n    }\r\n    language['lambda'].inside.arguments = arglist\r\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\r\n    language['defun'].inside.arguments.inside.sublist = arglist\r\n    Prism.languages.lisp = language\r\n    Prism.languages.elisp = language\r\n    Prism.languages.emacs = language\r\n    Prism.languages['emacs-lisp'] = language\r\n  })(Prism)\r\n}\r\n"],"names":["lisp","Prism","simple_form","name","RegExp","primitive","pattern","symbol","marker","par","endpar","space","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","elisp","emacs","module","exports","displayName","aliases"],"sourceRoot":""}