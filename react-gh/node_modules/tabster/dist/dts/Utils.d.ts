/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import * as Types from "./Types";
import { GetWindow, Visibility } from "./Types";
interface HTMLElementWithBoundingRectCacheId extends HTMLElement {
    __tabsterCacheId?: string;
}
export interface WindowWithUID extends Window {
    __tabsterCrossOriginWindowUID?: string;
}
export interface HTMLElementWithUID extends HTMLElement {
    __tabsterElementUID?: string;
}
export interface HTMLElementWithDummyContainer extends HTMLElement {
    __tabsterDummyContainer?: WeakHTMLElement;
}
export interface TabsterDOMRect {
    bottom: number;
    left: number;
    right: number;
    top: number;
}
export interface InstanceContext {
    elementByUId: {
        [uid: string]: WeakHTMLElement<HTMLElementWithUID>;
    };
    basics: InternalBasics;
    WeakRef?: WeakRefConstructor;
    containerBoundingRectCache: {
        [id: string]: {
            rect: TabsterDOMRect;
            element: HTMLElementWithBoundingRectCacheId;
        };
    };
    lastContainerBoundingRectCacheId: number;
    containerBoundingRectCacheTimer?: number;
    fakeWeakRefs: TabsterWeakRef<unknown>[];
    fakeWeakRefsTimer?: number;
    fakeWeakRefsStarted: boolean;
}
export declare function getInstanceContext(getWindow: GetWindow): InstanceContext;
export declare function disposeInstanceContext(win: Window): void;
export declare function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V>;
interface TabsterWeakRef<T> {
    deref(): T | undefined;
}
export declare class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined> implements Types.WeakHTMLElement<D> {
    private _ref;
    private _data;
    constructor(getWindow: GetWindow, element: T, data?: D);
    get(): T | undefined;
    getData(): D | undefined;
}
export declare function cleanupFakeWeakRefs(getWindow: GetWindow, forceRemove?: boolean): void;
export declare function startFakeWeakRefsCleanup(getWindow: GetWindow): void;
export declare function stopFakeWeakRefsCleanupAndClearStorage(getWindow: GetWindow): void;
export declare function createElementTreeWalker(doc: Document, root: Node, acceptNode: (node: Node) => number): TreeWalker | undefined;
export declare function getBoundingRect(getWindow: GetWindow, element: HTMLElementWithBoundingRectCacheId): TabsterDOMRect;
export declare function isElementVerticallyVisibleInContainer(getWindow: GetWindow, element: HTMLElement): boolean;
export declare function isElementVisibleInContainer(getWindow: GetWindow, element: HTMLElement, gap?: number): Visibility;
export declare function scrollIntoView(getWindow: GetWindow, element: HTMLElement, alignToTop: boolean): void;
export declare function getScrollableContainer(element: HTMLElement): HTMLElement | null;
export declare function makeFocusIgnored(element: HTMLElement): void;
export declare function shouldIgnoreFocus(element: HTMLElement): boolean;
export declare function getUId(wnd: Window & {
    msCrypto?: Crypto;
}): string;
export declare function getElementUId(getWindow: GetWindow, element: HTMLElementWithUID): string;
export declare function getElementByUId(context: InstanceContext, uid: string): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined;
export declare function getWindowUId(win: WindowWithUID): string;
export declare function clearElementCache(getWindow: GetWindow, parent?: HTMLElement): void;
export declare function documentContains(doc: HTMLDocument | null | undefined, element: HTMLElement): boolean;
export declare function matchesSelector(element: HTMLElement, selector: string): boolean;
export declare function getPromise(getWindow: GetWindow): PromiseConstructor;
export declare function getWeakRef(context: InstanceContext): WeakRefConstructor | undefined;
interface InternalBasics {
    Promise?: PromiseConstructor;
    WeakRef?: WeakRefConstructor;
    WeakMap?: WeakMapConstructor;
}
export declare function setBasics(win: Window, basics: InternalBasics): void;
export declare abstract class TabsterPart<P, D = undefined> implements Types.TabsterPart<P> {
    protected _tabster: Types.TabsterCore;
    protected _element: WeakHTMLElement<HTMLElement, D>;
    protected _props: P;
    readonly id: string;
    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P);
    getElement(): HTMLElement | undefined;
    getProps(): P;
    setProps(props: P): void;
}
export interface DummyInputProps {
    /** The input is created to be used only once and autoremoved when focused. */
    isPhantom?: boolean;
    /** Whether the input is before or after the content it is guarding.  */
    isFirst: boolean;
}
export type DummyInputFocusCallback = (dummyInput: DummyInput, isBackward: boolean, relatedTarget: HTMLElement | null) => void;
/**
 * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them
 */
export declare class DummyInput {
    private _isPhantom;
    private _disposeTimer;
    private _clearDisposeTimeout;
    input: HTMLElement | undefined;
    /** Flag that indicates focus is leaving the boundary of the dummy input */
    shouldMoveOut?: boolean;
    isFirst: DummyInputProps["isFirst"];
    isOutside: boolean;
    /** Called when the input is focused */
    onFocusIn?: DummyInputFocusCallback;
    /** Called when the input is blurred */
    onFocusOut?: DummyInputFocusCallback;
    constructor(getWindow: Types.GetWindow, isOutside: boolean, props: DummyInputProps, element?: WeakHTMLElement);
    dispose(): void;
    setTopLeft(top: number, left: number): void;
    private _isBackward;
    private _focusIn;
    private _focusOut;
}
export declare const DummyInputManagerPriorities: {
    Root: number;
    Modalizer: number;
    Mover: number;
    Groupper: number;
};
export declare class DummyInputManager {
    private _instance?;
    private _onFocusIn?;
    private _onFocusOut?;
    protected _element: WeakHTMLElement;
    private static _lastPhantomFrom;
    moveOutWithDefaultAction: DummyInputManagerCore["moveOutWithDefaultAction"];
    constructor(tabster: Types.TabsterCore, element: WeakHTMLElement, priority: number, outsideByDefault?: boolean);
    protected _setHandlers(onFocusIn?: DummyInputFocusCallback, onFocusOut?: DummyInputFocusCallback): void;
    getHandler(isIn: boolean): DummyInputFocusCallback | undefined;
    setTabbable(tabbable: boolean): void;
    dispose(): void;
    static getLastPhantomFrom(): HTMLElement | undefined;
    static moveWithPhantomDummy(tabster: Types.TabsterCore, element: HTMLElement, moveOutside: boolean, isBackward: boolean): void;
}
/**
 * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)
 */
declare class DummyInputManagerCore {
    private _unobserve;
    private _addTimer;
    private _getWindow;
    private _wrappers;
    private _element;
    private _isOutside;
    private _firstDummy;
    private _lastDummy;
    private _transformElements;
    private _scrollTimer;
    constructor(tabster: Types.TabsterCore, element: WeakHTMLElement, manager: DummyInputManager, priority: number, outsideByDefault?: boolean);
    dispose(manager: DummyInputManager, force?: boolean): void;
    private _onFocus;
    private _onFocusIn;
    private _onFocusOut;
    /**
     * Prepares to move focus out of the given element by focusing
     * one of the dummy inputs and setting the `shouldMoveOut` flag
     * @param backwards focus moving to an element behind the given element
     */
    moveOutWithDefaultAction: (backwards: boolean) => void;
    setTabbable: (manager: DummyInputManager, tabbable: boolean) => void;
    private _getCurrent;
    /**
     * Adds dummy inputs as the first and last child of the given element
     * Called each time the children under the element is mutated
     */
    private _addDummyInputs;
    /**
     * Creates a mutation observer to ensure that on DOM changes, the dummy inputs
     * stay as the first and last child elements
     */
    private _observeMutations;
    private _addTransformOffsets;
    private _reallyAddTransformOffsets;
}
export declare function getLastChild(container: HTMLElement): HTMLElement | undefined;
export declare function getAdjacentElement(from: HTMLElement, prev?: boolean): HTMLElement | undefined;
export declare function triggerEvent<D>(target: HTMLElement | EventTarget, name: string, details: D): boolean;
export {};
