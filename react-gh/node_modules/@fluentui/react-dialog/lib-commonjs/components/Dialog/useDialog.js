"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDialog_unstable = void 0;

const React = /*#__PURE__*/require("react");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_context_selector_1 = /*#__PURE__*/require("@fluentui/react-context-selector");

const utils_1 = /*#__PURE__*/require("../../utils");

const contexts_1 = /*#__PURE__*/require("../../contexts");
/**
 * Create the state required to render Dialog.
 *
 * The returned state can be modified with hooks such as useDialogStyles_unstable,
 * before being passed to renderDialog_unstable.
 *
 * @param props - props from this instance of Dialog
 */


const useDialog_unstable = props => {
  const {
    children,
    modalType = 'modal',
    onOpenChange
  } = props;
  const [trigger, content] = childrenToTriggerAndContent(children);
  const [open, setOpen] = react_utilities_1.useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const requestOpenChange = react_utilities_1.useEventCallback(data => {
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data.event, data); // if user prevents default then do not change state value
    // otherwise updates state value and trigger reference to the element that caused the opening

    if (!data.event.isDefaultPrevented()) {
      setOpen(data.open);
    }
  });
  const focusRef = utils_1.useFocusFirstElement(open, modalType);
  const disableBodyScroll = utils_1.useDisableBodyScroll();
  const isBodyScrollLocked = Boolean(open && modalType !== 'non-modal');
  react_utilities_1.useIsomorphicLayoutEffect(() => {
    if (isBodyScrollLocked) {
      return disableBodyScroll();
    }
  }, [disableBodyScroll, isBodyScrollLocked]);
  return {
    components: {
      backdrop: 'div'
    },
    open,
    modalType,
    content: open ? content : null,
    trigger,
    requestOpenChange,
    dialogTitleId: react_utilities_1.useId('dialog-title-'),
    isNestedDialog: react_context_selector_1.useHasParentContext(contexts_1.DialogContext),
    dialogRef: focusRef
  };
};

exports.useDialog_unstable = useDialog_unstable;
/**
 * Extracts trigger and content from children
 */

function childrenToTriggerAndContent(children) {
  const childrenArray = React.Children.toArray(children);

  if (process.env.NODE_ENV !== 'production') {
    if (childrenArray.length !== 1 && childrenArray.length !== 2) {
      // eslint-disable-next-line no-console
      console.warn('Dialog must contain at least one child <DialogSurface/>,\n' + 'and at most two children <DialogTrigger/> <DialogSurface/> (in this order)');
    }
  }

  switch (childrenArray.length) {
    // case where there's a trigger followed by content
    case 2:
      return childrenArray;
    // case where there's only content

    case 1:
      return [undefined, childrenArray[0]];
    // unknown case

    default:
      return [undefined, undefined];
  }
}
//# sourceMappingURL=useDialog.js.map