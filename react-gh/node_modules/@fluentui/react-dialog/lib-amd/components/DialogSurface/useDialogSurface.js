define(["require", "exports", "tslib", "@fluentui/react-utilities", "../../contexts", "../../utils", "@fluentui/react-tabster"], function (require, exports, tslib_1, react_utilities_1, contexts_1, utils_1, react_tabster_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDialogSurface_unstable = void 0;
    /**
     * Create the state required to render DialogSurface.
     *
     * The returned state can be modified with hooks such as useDialogSurfaceStyles_unstable,
     * before being passed to renderDialogSurface_unstable.
     *
     * @param props - props from this instance of DialogSurface
     * @param ref - reference to root HTMLElement of DialogSurface
     */
    var useDialogSurface_unstable = function (props, ref) {
        var backdrop = props.backdrop, as = props.as;
        var modalType = contexts_1.useDialogContext_unstable(function (ctx) { return ctx.modalType; });
        var dialogRef = contexts_1.useDialogContext_unstable(function (ctx) { return ctx.dialogRef; });
        var open = contexts_1.useDialogContext_unstable(function (ctx) { return ctx.open; });
        var requestOpenChange = contexts_1.useDialogContext_unstable(function (ctx) { return ctx.requestOpenChange; });
        var dialogTitleID = contexts_1.useDialogContext_unstable(function (ctx) { return ctx.dialogTitleId; });
        var handledBackdropClick = react_utilities_1.useEventCallback(function (event) {
            var _a, _b;
            if (react_utilities_1.isResolvedShorthand(props.backdrop)) {
                (_b = (_a = props.backdrop).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);
            }
            if (modalType === 'modal' && !event.isDefaultPrevented()) {
                requestOpenChange({
                    event: event,
                    open: false,
                    type: 'backdropClick',
                });
            }
        });
        var handleKeyDown = react_utilities_1.useEventCallback(function (event) {
            var _a;
            (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, event);
            if (utils_1.isEscapeKeyDismiss(event, modalType)) {
                requestOpenChange({
                    event: event,
                    open: false,
                    type: 'escapeKeyDown',
                });
                // stop propagation to avoid conflicting with other elements that listen for `Escape`
                // e,g: nested Dialog, Popover, Menu and Tooltip
                event.stopPropagation();
            }
        });
        var modalAttributes = react_tabster_1.useModalAttributes({ trapFocus: modalType !== 'non-modal' }).modalAttributes;
        return {
            components: {
                backdrop: 'div',
                root: 'div',
            },
            backdrop: react_utilities_1.resolveShorthand(backdrop, {
                required: open && modalType !== 'non-modal',
                defaultProps: {
                    'aria-hidden': 'true',
                    onClick: handledBackdropClick,
                },
            }),
            root: react_utilities_1.getNativeElementProps(as !== null && as !== void 0 ? as : 'div', tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ tabIndex: -1, 'aria-modal': modalType !== 'non-modal', role: modalType === 'alert' ? 'alertdialog' : 'dialog', 'aria-labelledby': props['aria-label'] ? undefined : dialogTitleID }, props), modalAttributes), { onKeyDown: handleKeyDown, ref: react_utilities_1.useMergedRefs(ref, dialogRef) })),
        };
    };
    exports.useDialogSurface_unstable = useDialogSurface_unstable;
});
//# sourceMappingURL=useDialogSurface.js.map