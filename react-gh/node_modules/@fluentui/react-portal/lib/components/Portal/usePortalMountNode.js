import * as React from 'react';
import { useThemeClassName_unstable as useThemeClassName, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { __styles, mergeClasses } from '@griffel/react';
import { useFocusVisible } from '@fluentui/react-tabster';

const useStyles = /*#__PURE__*/__styles({
  "root": {
    "qhf8xq": "f10pi13n",
    "Bj3rh1h": "f494woh"
  }
}, {
  "d": [".f10pi13n{position:relative;}", ".f494woh{z-index:1000000;}"]
});
/**
 * Creates a new element on a document.body to mount portals
 */


export const usePortalMountNode = options => {
  const {
    targetDocument,
    dir
  } = useFluent();
  const focusVisibleRef = useFocusVisible();
  const classes = useStyles();
  const themeClassName = useThemeClassName();
  const className = mergeClasses(themeClassName, classes.root);
  const element = React.useMemo(() => {
    if (targetDocument === undefined || options.disabled) {
      return null;
    }

    const newElement = targetDocument.createElement('div');
    targetDocument.body.appendChild(newElement);
    return newElement;
  }, [targetDocument, options.disabled]); // This useMemo call is intentional
  // We don't want to re-create the portal element when its attributes change.
  // This also should not be done in an effect because, changing the value of css variables
  // after initial mount can trigger interesting CSS side effects like transitions.

  React.useMemo(() => {
    if (element) {
      const classesToApply = className.split(' ').filter(Boolean);
      element.classList.add(...classesToApply);
      element.setAttribute('dir', dir);
      focusVisibleRef.current = element;
      return () => {
        element.classList.remove(...classesToApply);
        element.removeAttribute('dir');
      };
    }
  }, [className, dir, element, focusVisibleRef]);
  React.useEffect(() => {
    return () => {
      var _a;

      (_a = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);
    };
  }, [element]);
  return element;
};
//# sourceMappingURL=usePortalMountNode.js.map