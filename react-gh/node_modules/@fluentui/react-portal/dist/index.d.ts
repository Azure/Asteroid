import * as React_2 from 'react';

/**
 * Similar functionality to `element.contains` DOM API for use with out of order DOM elements that
 * checks the virtual parent hierarchy. If a virtual parents exists, it is chosen over the actual parent
 *
 * @returns true if the child can find the parent in its virtual hierarchy
 */
export declare function elementContains(parent: HTMLElement | null, child: HTMLElement | null): boolean;

/**
 * A portal provides a way to render children into a DOM node
 * that exists outside the DOM hierarchy of the parent component.
 */
export declare const Portal: React_2.FC<PortalProps>;

export declare type PortalProps = {
    /**
     * React children
     */
    children?: React_2.ReactNode;
    /**
     * Where the portal children are mounted on DOM
     *
     * @default a new element on document.body without any styling
     */
    mountNode?: HTMLElement | null;
};

export declare type PortalState = Pick<PortalProps, 'children'> & Required<Pick<PortalProps, 'mountNode'>> & {
    /**
     * Ref to the root span element as virtual parent
     */
    virtualParentRootRef: React_2.MutableRefObject<HTMLSpanElement | null>;
};

/**
 * Render the final JSX of Portal
 */
export declare const renderPortal_unstable: (state: PortalState) => React_2.ReactElement;

/**
 * Sets the virtual parent of an element.
 *
 * @param child - Theme element to set the virtual parent
 * @param parent - The virtual parent, use `undefined` to remove a virtual parent relationship
 */
export declare function setVirtualParent(child: HTMLElement, parent?: HTMLElement): void;

/**
 * Create the state required to render Portal.
 *
 * The returned state can be modified with hooks such as usePortalStyles, before being passed to renderPortal_unstable.
 *
 * @param props - props from this instance of Portal
 */
export declare const usePortal_unstable: (props: PortalProps) => PortalState;

export { }
