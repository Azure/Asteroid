define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/react-tabster"], function (require, exports, tslib_1, React, react_utilities_1, react_tabster_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAccordion_unstable = void 0;
    /**
     * Returns the props and state required to render the component
     * @param props - Accordion properties
     * @param ref - reference to root HTMLElement of Accordion
     */
    var useAccordion_unstable = function (props, ref) {
        var controlledOpenItems = props.openItems, defaultOpenItems = props.defaultOpenItems, _a = props.multiple, multiple = _a === void 0 ? false : _a, _b = props.collapsible, collapsible = _b === void 0 ? false : _b, onToggle = props.onToggle, navigation = props.navigation;
        var _c = react_utilities_1.useControllableState({
            state: React.useMemo(function () { return normalizeValues(controlledOpenItems); }, [controlledOpenItems]),
            defaultState: function () { return initializeUncontrolledOpenItems({ defaultOpenItems: defaultOpenItems, multiple: multiple }); },
            initialState: [],
        }), openItems = _c[0], setOpenItems = _c[1];
        var arrowNavigationProps = react_tabster_1.useArrowNavigationGroup({
            circular: navigation === 'circular',
            tabbable: true,
        });
        var requestToggle = react_utilities_1.useEventCallback(function (event, data) {
            onToggle === null || onToggle === void 0 ? void 0 : onToggle(event, data);
            setOpenItems(function (previousOpenItems) { return updateOpenItems(data.value, previousOpenItems, multiple, collapsible); });
        });
        return {
            collapsible: collapsible,
            navigation: navigation,
            openItems: openItems,
            requestToggle: requestToggle,
            components: {
                root: 'div',
            },
            root: react_utilities_1.getNativeElementProps('div', tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, props), (navigation ? arrowNavigationProps : {})), { ref: ref })),
        };
    };
    exports.useAccordion_unstable = useAccordion_unstable;
    /**
     * Initial value for the uncontrolled case of the list of open indexes
     */
    function initializeUncontrolledOpenItems(_a) {
        var defaultOpenItems = _a.defaultOpenItems, multiple = _a.multiple;
        if (defaultOpenItems !== undefined) {
            if (Array.isArray(defaultOpenItems)) {
                return multiple ? defaultOpenItems : [defaultOpenItems[0]];
            }
            return [defaultOpenItems];
        }
        return [];
    }
    /**
     * Updates the list of open indexes based on an index that changes
     * @param value - the index that will change
     * @param previousOpenItems - list of current open indexes
     * @param multiple - if Accordion support multiple Panels opened at the same time
     * @param collapsible - if Accordion support multiple Panels closed at the same time
     */
    function updateOpenItems(value, previousOpenItems, multiple, collapsible) {
        if (multiple) {
            if (previousOpenItems.includes(value)) {
                if (previousOpenItems.length > 1 || collapsible) {
                    return previousOpenItems.filter(function (i) { return i !== value; });
                }
            }
            else {
                return tslib_1.__spreadArray(tslib_1.__spreadArray([], previousOpenItems), [value]).sort();
            }
        }
        else {
            return previousOpenItems[0] === value && collapsible ? [] : [value];
        }
        return previousOpenItems;
    }
    /**
     * Normalizes Accordion index into an array of indexes
     */
    function normalizeValues(index) {
        if (index === undefined) {
            return undefined;
        }
        return Array.isArray(index) ? index : [index];
    }
});
//# sourceMappingURL=useAccordion.js.map