define(["require", "exports", "tslib", "react", "@fluentui/react-tabster", "@fluentui/react-utilities"], function (require, exports, tslib_1, React, react_tabster_1, react_utilities_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTabList_unstable = void 0;
    /**
     * Create the state required to render TabList.
     *
     * The returned state can be modified with hooks such as useTabListStyles_unstable,
     * before being passed to renderTabList_unstable.
     *
     * @param props - props from this instance of TabList
     * @param ref - reference to root HTMLElement of TabList
     */
    var useTabList_unstable = function (props, ref) {
        var _a = props.appearance, appearance = _a === void 0 ? 'transparent' : _a, _b = props.reserveSelectedTabSpace, reserveSelectedTabSpace = _b === void 0 ? true : _b, _c = props.disabled, disabled = _c === void 0 ? false : _c, onTabSelect = props.onTabSelect, _d = props.size, size = _d === void 0 ? 'medium' : _d, _e = props.vertical, vertical = _e === void 0 ? false : _e;
        var innerRef = React.useRef(null);
        var focusAttributes = react_tabster_1.useArrowNavigationGroup({
            circular: true,
            axis: vertical ? 'vertical' : 'horizontal',
            memorizeCurrent: true,
        });
        var _f = react_utilities_1.useControllableState({
            state: props.selectedValue,
            defaultState: props.defaultSelectedValue,
            initialState: undefined,
        }), selectedValue = _f[0], setSelectedValue = _f[1];
        // considered usePrevious, but it is sensitive to re-renders
        // this could cause the previous to move to current in the case where the tab list re-renders.
        // these refs avoid getRegisteredTabs changing when selectedValue changes and causing
        // renders for tabs that have not changed.
        var currentSelectedValue = React.useRef(undefined);
        var previousSelectedValue = React.useRef(undefined);
        React.useEffect(function () {
            previousSelectedValue.current = currentSelectedValue.current;
            currentSelectedValue.current = selectedValue;
        }, [selectedValue]);
        var onSelect = react_utilities_1.useEventCallback(function (event, data) {
            setSelectedValue(data.value);
            onTabSelect === null || onTabSelect === void 0 ? void 0 : onTabSelect(event, data);
        });
        var registeredTabs = React.useRef({});
        var onRegister = react_utilities_1.useEventCallback(function (data) {
            registeredTabs.current[JSON.stringify(data.value)] = data;
        });
        var onUnregister = react_utilities_1.useEventCallback(function (data) {
            delete registeredTabs.current[JSON.stringify(data.value)];
        });
        var getRegisteredTabs = React.useCallback(function () {
            return {
                selectedValue: currentSelectedValue.current,
                previousSelectedValue: previousSelectedValue.current,
                registeredTabs: registeredTabs.current,
            };
        }, []);
        return {
            components: {
                root: 'div',
            },
            root: react_utilities_1.getNativeElementProps('div', tslib_1.__assign(tslib_1.__assign({ ref: react_utilities_1.useMergedRefs(ref, innerRef), role: 'tablist' }, focusAttributes), props)),
            appearance: appearance,
            reserveSelectedTabSpace: reserveSelectedTabSpace,
            disabled: disabled,
            selectedValue: selectedValue,
            size: size,
            vertical: vertical,
            onRegister: onRegister,
            onUnregister: onUnregister,
            onSelect: onSelect,
            getRegisteredTabs: getRegisteredTabs,
        };
    };
    exports.useTabList_unstable = useTabList_unstable;
});
//# sourceMappingURL=useTabList.js.map