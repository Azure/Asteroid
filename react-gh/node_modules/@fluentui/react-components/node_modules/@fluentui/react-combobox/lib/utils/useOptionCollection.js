import * as React from 'react';
/**
 * A hook for managing a collection of child Options
 */

export const useOptionCollection = () => {
  const nodes = React.useRef([]);
  const collectionAPI = React.useMemo(() => {
    const getCount = () => nodes.current.length;

    const getOptionAtIndex = index => {
      var _a;

      return (_a = nodes.current[index]) === null || _a === void 0 ? void 0 : _a.option;
    };

    const getIndexOfId = id => nodes.current.findIndex(node => node.option.id === id);

    const getOptionById = id => {
      const item = nodes.current.find(node => node.option.id === id);
      return item === null || item === void 0 ? void 0 : item.option;
    };

    const getOptionsMatchingText = matcher => {
      return nodes.current.filter(node => matcher(node.option.text)).map(node => node.option);
    };

    return {
      getCount,
      getOptionAtIndex,
      getIndexOfId,
      getOptionById,
      getOptionsMatchingText
    };
  }, []);
  const registerOption = React.useCallback((option, element) => {
    var _a;

    const index = nodes.current.findIndex(node => {
      if (!node.element || !element) {
        return false;
      }

      if (node.option.id === option.id) {
        return true;
      } // use the DOM method compareDocumentPosition to order the current node against registered nodes
      // eslint-disable-next-line no-bitwise


      return node.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING;
    }); // do not register the option if it already exists

    if (((_a = nodes.current[index]) === null || _a === void 0 ? void 0 : _a.option.id) !== option.id) {
      const newItem = {
        element,
        option
      }; // If an index is not found we will push the element to the end.

      if (index === -1) {
        nodes.current = [...nodes.current, newItem];
      } else {
        nodes.current.splice(index, 0, newItem);
      }
    } // return the unregister function


    return () => {
      nodes.current = nodes.current.filter(node => node.option.id !== option.id);
    };
  }, []);
  return { ...collectionAPI,
    options: nodes.current.map(node => node.option),
    registerOption
  };
};
//# sourceMappingURL=useOptionCollection.js.map