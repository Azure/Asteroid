"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDropdown_unstable = void 0;

const React = /*#__PURE__*/require("react");

const react_icons_1 = /*#__PURE__*/require("@fluentui/react-icons");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const dropdownKeyActions_1 = /*#__PURE__*/require("../../utils/dropdownKeyActions");

const useComboboxBaseState_1 = /*#__PURE__*/require("../../utils/useComboboxBaseState");

const useComboboxPopup_1 = /*#__PURE__*/require("../../utils/useComboboxPopup");

const useTriggerListboxSlots_1 = /*#__PURE__*/require("../../utils/useTriggerListboxSlots");

const Listbox_1 = /*#__PURE__*/require("../Listbox/Listbox");

const react_utilities_2 = /*#__PURE__*/require("@fluentui/react-utilities");
/**
 * Create the state required to render Dropdown.
 *
 * The returned state can be modified with hooks such as useDropdownStyles_unstable,
 * before being passed to renderDropdown_unstable.
 *
 * @param props - props from this instance of Dropdown
 * @param ref - reference to root HTMLElement of Dropdown
 */


const useDropdown_unstable = (props, ref) => {
  const baseState = useComboboxBaseState_1.useComboboxBaseState(props);
  const {
    activeOption,
    getIndexOfId,
    getOptionsMatchingText,
    open,
    setActiveOption,
    setFocusVisible,
    setOpen
  } = baseState;
  const {
    primary: triggerNativeProps,
    root: rootNativeProps
  } = react_utilities_1.getPartitionedNativeProps({
    props,
    primarySlotTagName: 'button',
    excludedPropNames: ['children']
  }); // set listbox popup width based off the root/trigger width

  const rootRef = React.useRef(null);
  const [popupWidth, setPopupWidth] = React.useState();
  React.useEffect(() => {
    var _a;

    const width = open ? `${(_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth}px` : undefined;
    setPopupWidth(width);
  }, [open]); // jump to matching option based on typing

  const searchString = React.useRef('');
  const [setKeyTimeout, clearKeyTimeout] = react_utilities_1.useTimeout();

  const getNextMatchingOption = () => {
    var _a; // first check for matches for the full searchString


    let matcher = optionValue => optionValue.toLowerCase().indexOf(searchString.current) === 0;

    let matches = getOptionsMatchingText(matcher);
    let startIndex = activeOption ? getIndexOfId(activeOption.id) : 0; // if the dropdown is already open and the searchstring is a single character,
    // then look after the current activeOption for letters
    // this is so slowly typing the same letter will cycle through matches

    if (open && searchString.current.length === 1) {
      startIndex++;
    } // if there are no direct matches, check if the search is all the same letter, e.g. "aaa"


    if (!matches.length) {
      const letters = searchString.current.split('');
      const allSameLetter = letters.length && letters.every(letter => letter === letters[0]); // if the search is all the same letter, cycle through options starting with that letter

      if (allSameLetter) {
        startIndex++;

        matcher = optionValue => optionValue.toLowerCase().indexOf(letters[0]) === 0;

        matches = getOptionsMatchingText(matcher);
      }
    } // if there is an active option and multiple matches,
    // return first matching option after the current active option, looping back to the top


    if (matches.length > 1 && activeOption) {
      const nextMatch = matches.find(option => getIndexOfId(option.id) >= startIndex);
      return nextMatch !== null && nextMatch !== void 0 ? nextMatch : matches[0];
    }

    return (_a = matches[0]) !== null && _a !== void 0 ? _a : undefined;
  };

  const onTriggerKeyDown = ev => {
    // clear timeout, if it exists
    clearKeyTimeout(); // if the key was a char key, update search string

    if (dropdownKeyActions_1.getDropdownActionFromKey(ev) === 'Type') {
      // update search string
      searchString.current += ev.key.toLowerCase();
      setKeyTimeout(() => {
        searchString.current = '';
      }, 500); // update state

      !open && setOpen(ev, true);
      const nextOption = getNextMatchingOption();
      setActiveOption(nextOption);
      setFocusVisible(true);
    }
  }; // resolve button and listbox slot props


  let triggerSlot;
  let listboxSlot;
  triggerSlot = react_utilities_1.resolveShorthand(props.button, {
    required: true,
    defaultProps: {
      type: 'button',
      children: baseState.value || props.placeholder,
      ...triggerNativeProps
    }
  });
  triggerSlot.onKeyDown = react_utilities_1.mergeCallbacks(onTriggerKeyDown, triggerSlot.onKeyDown);
  listboxSlot = baseState.open || baseState.hasFocus ? react_utilities_1.resolveShorthand(props.listbox, {
    required: true,
    defaultProps: {
      children: props.children,
      style: {
        width: popupWidth
      }
    }
  }) : undefined;
  [triggerSlot, listboxSlot] = useComboboxPopup_1.useComboboxPopup(props, triggerSlot, listboxSlot);
  [triggerSlot, listboxSlot] = useTriggerListboxSlots_1.useTriggerListboxSlots(props, baseState, ref, triggerSlot, listboxSlot);
  const state = {
    components: {
      root: 'div',
      button: 'button',
      expandIcon: 'span',
      listbox: Listbox_1.Listbox
    },
    root: react_utilities_1.resolveShorthand(props.root, {
      required: true,
      defaultProps: {
        children: props.children,
        ...rootNativeProps
      }
    }),
    button: triggerSlot,
    listbox: listboxSlot,
    expandIcon: react_utilities_1.resolveShorthand(props.expandIcon, {
      required: true,
      defaultProps: {
        children: React.createElement(react_icons_1.ChevronDownRegular, null)
      }
    }),
    placeholderVisible: !baseState.value && !!props.placeholder,
    ...baseState
  };
  state.root.ref = react_utilities_2.useMergedRefs(state.root.ref, rootRef);
  return state;
};

exports.useDropdown_unstable = useDropdown_unstable;
//# sourceMappingURL=useDropdown.js.map