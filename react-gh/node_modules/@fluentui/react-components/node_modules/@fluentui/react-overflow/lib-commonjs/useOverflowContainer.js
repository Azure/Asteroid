"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateVisibilityAttribute = exports.useOverflowContainer = void 0;

const React = /*#__PURE__*/require("react");

const priority_overflow_1 = /*#__PURE__*/require("@fluentui/priority-overflow");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const constants_1 = /*#__PURE__*/require("./constants");
/**
 * @internal
 * @param update - Callback when overflow state changes
 * @param options - Options to configure the overflow container
 * @returns - ref to attach to an intrinsic HTML element and imperative functions
 */


const useOverflowContainer = (update, options) => {
  const {
    overflowAxis,
    overflowDirection,
    padding,
    minimumVisible,
    onUpdateItemVisibility
  } = options; // DOM ref to the overflow container element

  const containerRef = React.useRef(null);
  const updateOverflowItems = react_utilities_1.useEventCallback(update);
  const [overflowManager] = React.useState(() => react_utilities_1.canUseDOM() ? priority_overflow_1.createOverflowManager() : null);
  react_utilities_1.useIsomorphicLayoutEffect(() => {
    if (!containerRef.current) {
      return;
    }

    if (overflowManager) {
      overflowManager.observe(containerRef.current, {
        overflowDirection: overflowDirection !== null && overflowDirection !== void 0 ? overflowDirection : 'end',
        overflowAxis: overflowAxis !== null && overflowAxis !== void 0 ? overflowAxis : 'horizontal',
        padding: padding !== null && padding !== void 0 ? padding : 10,
        minimumVisible: minimumVisible !== null && minimumVisible !== void 0 ? minimumVisible : 0,
        onUpdateItemVisibility: onUpdateItemVisibility !== null && onUpdateItemVisibility !== void 0 ? onUpdateItemVisibility : () => undefined,
        onUpdateOverflow: updateOverflowItems !== null && updateOverflowItems !== void 0 ? updateOverflowItems : () => undefined
      });
      return () => {
        overflowManager.disconnect();
      };
    }
  }, [updateOverflowItems, overflowManager, overflowDirection, overflowAxis, padding, minimumVisible, onUpdateItemVisibility]);
  const registerItem = React.useCallback(item => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addItem(item);
    item.element.setAttribute(constants_1.DATA_OVERFLOW_ITEM, '');
    return () => {
      item.element.removeAttribute(constants_1.DATA_OVERFLOWING);
      item.element.removeAttribute(constants_1.DATA_OVERFLOW_ITEM);
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeItem(item.id);
    };
  }, [overflowManager]);
  const updateOverflow = React.useCallback(() => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.update();
  }, [overflowManager]);
  const registerOverflowMenu = React.useCallback(el => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addOverflowMenu(el);
    el.setAttribute(constants_1.DATA_OVERFLOW_MENU, '');
    return () => {
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeOverflowMenu();
      el.removeAttribute(constants_1.DATA_OVERFLOW_MENU);
    };
  }, [overflowManager]);
  return {
    containerRef,
    registerItem,
    updateOverflow,
    registerOverflowMenu
  };
};

exports.useOverflowContainer = useOverflowContainer;

const updateVisibilityAttribute = ({
  item,
  visible
}) => {
  if (visible) {
    item.element.removeAttribute(constants_1.DATA_OVERFLOWING);
  } else {
    item.element.setAttribute(constants_1.DATA_OVERFLOWING, '');
  }
};

exports.updateVisibilityAttribute = updateVisibilityAttribute;
//# sourceMappingURL=useOverflowContainer.js.map