define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/react-shared-contexts", "./useCharacterSearch", "../../contexts/menuTriggerContext", "@fluentui/react-icons", "../../contexts/menuListContext", "../../contexts/menuContext", "@fluentui/react-aria", "@fluentui/keyboard-keys"], function (require, exports, tslib_1, React, react_utilities_1, react_shared_contexts_1, useCharacterSearch_1, menuTriggerContext_1, react_icons_1, menuListContext_1, menuContext_1, react_aria_1, keyboard_keys_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMenuItem_unstable = void 0;
    var ChevronRightIcon = react_icons_1.bundleIcon(react_icons_1.ChevronRightFilled, react_icons_1.ChevronRightRegular);
    var ChevronLeftIcon = react_icons_1.bundleIcon(react_icons_1.ChevronLeftFilled, react_icons_1.ChevronLeftRegular);
    /**
     * Returns the props and state required to render the component
     */
    var useMenuItem_unstable = function (props, ref) {
        var isSubmenuTrigger = menuTriggerContext_1.useMenuTriggerContext_unstable();
        var persistOnClickContext = menuContext_1.useMenuContext_unstable(function (context) { return context.persistOnItemClick; });
        var _a = props.as, as = _a === void 0 ? 'div' : _a, disabled = props.disabled, disabledFocusable = props.disabledFocusable, _b = props.hasSubmenu, hasSubmenu = _b === void 0 ? isSubmenuTrigger : _b, _c = props.persistOnClick, persistOnClick = _c === void 0 ? persistOnClickContext : _c;
        var hasIcons = menuListContext_1.useMenuListContext_unstable(function (context) { return context.hasIcons; });
        var hasCheckmarks = menuListContext_1.useMenuListContext_unstable(function (context) { return context.hasCheckmarks; });
        var setOpen = menuContext_1.useMenuContext_unstable(function (context) { return context.setOpen; });
        var dir = react_shared_contexts_1.useFluent_unstable().dir;
        var innerRef = React.useRef(null);
        var dismissedWithKeyboardRef = React.useRef(false);
        var isDisabled = Boolean(disabled || disabledFocusable);
        var state = {
            hasSubmenu: hasSubmenu,
            disabled: isDisabled,
            persistOnClick: persistOnClick,
            components: {
                root: 'div',
                icon: 'span',
                checkmark: 'span',
                submenuIndicator: 'span',
                content: 'span',
                secondaryContent: 'span',
            },
            isNativeButton: as === 'button',
            root: react_utilities_1.getNativeElementProps(as, react_aria_1.useARIAButtonShorthand({ disabled: false, disabledFocusable: isDisabled, as: as }, {
                required: true,
                defaultProps: tslib_1.__assign(tslib_1.__assign({ role: 'menuitem' }, props), { ref: react_utilities_1.useMergedRefs(ref, innerRef), onKeyDown: react_utilities_1.useEventCallback(function (event) {
                        var _a;
                        (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, event);
                        if (!event.isDefaultPrevented() && (event.key === keyboard_keys_1.Space || event.key === keyboard_keys_1.Enter)) {
                            dismissedWithKeyboardRef.current = true;
                        }
                    }), onMouseEnter: react_utilities_1.useEventCallback(function (event) {
                        var _a, _b;
                        (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                        (_b = props.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(props, event);
                    }), onClick: react_utilities_1.useEventCallback(function (event) {
                        var _a;
                        if (!hasSubmenu && !persistOnClick) {
                            setOpen(event, {
                                open: false,
                                keyboard: dismissedWithKeyboardRef.current,
                                bubble: true,
                                type: 'menuItemClick',
                                event: event,
                            });
                            dismissedWithKeyboardRef.current = false;
                        }
                        (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props, event);
                    }) }),
            })),
            icon: react_utilities_1.resolveShorthand(props.icon, { required: hasIcons }),
            checkmark: react_utilities_1.resolveShorthand(props.checkmark, { required: hasCheckmarks }),
            submenuIndicator: react_utilities_1.resolveShorthand(props.submenuIndicator, {
                required: hasSubmenu,
                defaultProps: {
                    children: dir === 'ltr' ? React.createElement(ChevronRightIcon, null) : React.createElement(ChevronLeftIcon, null),
                },
            }),
            content: react_utilities_1.resolveShorthand(props.content, {
                required: !!props.children,
                defaultProps: { children: props.children },
            }),
            secondaryContent: react_utilities_1.resolveShorthand(props.secondaryContent),
        };
        useCharacterSearch_1.useCharacterSearch(state, innerRef);
        return state;
    };
    exports.useMenuItem_unstable = useMenuItem_unstable;
});
//# sourceMappingURL=useMenuItem.js.map