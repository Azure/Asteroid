define(["require", "exports", "tslib", "react", "../../contexts/menuContext", "../../utils/useIsSubmenu", "@fluentui/react-tabster", "@fluentui/react-shared-contexts", "@fluentui/keyboard-keys", "@fluentui/react-utilities", "@fluentui/react-aria"], function (require, exports, tslib_1, React, menuContext_1, useIsSubmenu_1, react_tabster_1, react_shared_contexts_1, keyboard_keys_1, react_utilities_1, react_aria_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMenuTrigger_unstable = void 0;
    /**
     * Create the state required to render MenuTrigger.
     * Clones the only child component and adds necessary event handling behaviours to open a popup menu
     *
     * @param props - props from this instance of MenuTrigger
     */
    var useMenuTrigger_unstable = function (props) {
        var children = props.children, _a = props.disableButtonEnhancement, disableButtonEnhancement = _a === void 0 ? false : _a;
        var triggerRef = menuContext_1.useMenuContext_unstable(function (context) { return context.triggerRef; });
        var menuPopoverRef = menuContext_1.useMenuContext_unstable(function (context) { return context.menuPopoverRef; });
        var setOpen = menuContext_1.useMenuContext_unstable(function (context) { return context.setOpen; });
        var open = menuContext_1.useMenuContext_unstable(function (context) { return context.open; });
        var triggerId = menuContext_1.useMenuContext_unstable(function (context) { return context.triggerId; });
        var openOnHover = menuContext_1.useMenuContext_unstable(function (context) { return context.openOnHover; });
        var openOnContext = menuContext_1.useMenuContext_unstable(function (context) { return context.openOnContext; });
        var isSubmenu = useIsSubmenu_1.useIsSubmenu();
        var findFirstFocusable = react_tabster_1.useFocusFinders().findFirstFocusable;
        var focusFirst = React.useCallback(function () {
            var firstFocusable = findFirstFocusable(menuPopoverRef.current);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
        }, [findFirstFocusable, menuPopoverRef]);
        var openedWithKeyboardRef = React.useRef(false);
        var hasMouseMoved = React.useRef(false);
        var dir = react_shared_contexts_1.useFluent_unstable().dir;
        var OpenArrowKey = dir === 'ltr' ? keyboard_keys_1.ArrowRight : keyboard_keys_1.ArrowLeft;
        var child = react_utilities_1.getTriggerChild(children);
        var onContextMenu = function (event) {
            if (isTargetDisabled(event)) {
                return;
            }
            if (openOnContext) {
                event.preventDefault();
                setOpen(event, { open: true, keyboard: false, type: 'menuTriggerContextMenu', event: event });
            }
        };
        var onClick = function (event) {
            if (isTargetDisabled(event)) {
                return;
            }
            if (!openOnContext) {
                setOpen(event, { open: !open, keyboard: openedWithKeyboardRef.current, type: 'menuTriggerClick', event: event });
                openedWithKeyboardRef.current = false;
            }
        };
        var onKeyDown = function (event) {
            if (isTargetDisabled(event)) {
                return;
            }
            var key = event.key;
            if (!openOnContext && ((isSubmenu && key === OpenArrowKey) || (!isSubmenu && key === keyboard_keys_1.ArrowDown))) {
                setOpen(event, { open: true, keyboard: true, type: 'menuTriggerKeyDown', event: event });
            }
            if (key === keyboard_keys_1.Escape && !isSubmenu) {
                setOpen(event, { open: false, keyboard: true, type: 'menuTriggerKeyDown', event: event });
            }
            // if menu is already open, can't rely on effects to focus
            if (open && key === OpenArrowKey && isSubmenu) {
                focusFirst();
            }
        };
        var onMouseEnter = function (event) {
            if (isTargetDisabled(event)) {
                return;
            }
            if (openOnHover && hasMouseMoved.current) {
                setOpen(event, { open: true, keyboard: false, type: 'menuTriggerMouseEnter', event: event });
            }
        };
        // Opening a menu when a mouse hasn't moved and just entering the trigger is a bad a11y experience
        // First time open the mouse using mousemove and then continue with mouseenter
        // Only use once to determine that the user is using the mouse since it is an expensive event to handle
        var onMouseMove = function (event) {
            if (isTargetDisabled(event)) {
                return;
            }
            if (openOnHover && !hasMouseMoved.current) {
                setOpen(event, { open: true, keyboard: false, type: 'menuTriggerMouseMove', event: event });
                hasMouseMoved.current = true;
            }
        };
        var onMouseLeave = function (event) {
            if (isTargetDisabled(event)) {
                return;
            }
            if (openOnHover) {
                setOpen(event, { open: false, keyboard: false, type: 'menuTriggerMouseLeave', event: event });
            }
        };
        var contextMenuProps = tslib_1.__assign(tslib_1.__assign({ id: triggerId }, child === null || child === void 0 ? void 0 : child.props), { ref: react_utilities_1.useMergedRefs(triggerRef, child === null || child === void 0 ? void 0 : child.ref), onMouseEnter: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)), onMouseLeave: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)), onContextMenu: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)), onMouseMove: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove)) });
        var triggerChildProps = tslib_1.__assign(tslib_1.__assign({ 'aria-haspopup': 'menu', 'aria-expanded': !open && !isSubmenu ? undefined : open }, contextMenuProps), { onClick: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)), onKeyDown: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown)) });
        var ariaButtonTriggerChildProps = react_aria_1.useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === 'button' || (child === null || child === void 0 ? void 0 : child.type) === 'a' ? child.type : 'div', triggerChildProps);
        return {
            isSubmenu: isSubmenu,
            children: react_utilities_1.applyTriggerPropsToChildren(children, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps),
        };
    };
    exports.useMenuTrigger_unstable = useMenuTrigger_unstable;
    var isTargetDisabled = function (e) {
        var isDisabled = function (el) {
            return el.hasAttribute('disabled') || (el.hasAttribute('aria-disabled') && el.getAttribute('aria-disabled') === 'true');
        };
        if (e.target instanceof HTMLElement && isDisabled(e.target)) {
            return true;
        }
        return e.currentTarget instanceof HTMLElement && isDisabled(e.currentTarget);
    };
});
//# sourceMappingURL=useMenuTrigger.js.map