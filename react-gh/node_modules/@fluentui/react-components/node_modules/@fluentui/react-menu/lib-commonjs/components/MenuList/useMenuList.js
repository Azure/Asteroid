"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMenuList_unstable = void 0;

const React = /*#__PURE__*/require("react");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");

const react_context_selector_1 = /*#__PURE__*/require("@fluentui/react-context-selector");

const menuContext_1 = /*#__PURE__*/require("../../contexts/menuContext");

const menuContext_2 = /*#__PURE__*/require("../../contexts/menuContext");
/**
 * Returns the props and state required to render the component
 */


const useMenuList_unstable = (props, ref) => {
  const focusAttributes = react_tabster_1.useArrowNavigationGroup({
    circular: true,
    ignoreDefaultKeydown: {
      Tab: true
    }
  });
  const {
    findAllFocusable
  } = react_tabster_1.useFocusFinders();
  const menuContext = useMenuContextSelectors();
  const hasMenuContext = react_context_selector_1.useHasParentContext(menuContext_2.MenuContext);

  if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {
    // TODO throw warnings in development safely
    // eslint-disable-next-line no-console
    console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');
  }

  const innerRef = React.useRef(null);
  const setFocusByFirstCharacter = React.useCallback((e, itemEl) => {
    // TODO use some kind of children registration to reduce dependency on DOM roles
    const acceptedRoles = ['menuitem', 'menuitemcheckbox', 'menuitemradio'];

    if (!innerRef.current) {
      return;
    }

    const menuItems = findAllFocusable(innerRef.current, el => el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')) !== -1);
    let startIndex = menuItems.indexOf(itemEl) + 1;

    if (startIndex === menuItems.length) {
      startIndex = 0;
    }

    const firstChars = menuItems.map(menuItem => {
      var _a;

      return (_a = menuItem.textContent) === null || _a === void 0 ? void 0 : _a.charAt(0).toLowerCase();
    });
    const char = e.key.toLowerCase();

    const getIndexFirstChars = (start, firstChar) => {
      for (let i = start; i < firstChars.length; i++) {
        if (char === firstChars[i]) {
          return i;
        }
      }

      return -1;
    }; // Check remaining slots in the menu


    let index = getIndexFirstChars(startIndex, char); // If not found in remaining slots, check from beginning

    if (index === -1) {
      index = getIndexFirstChars(0, char);
    } // If match was found...


    if (index > -1) {
      menuItems[index].focus();
    }
  }, [findAllFocusable]);
  const [checkedValues, setCheckedValues] = react_utilities_1.useControllableState({
    state: hasMenuContext ? menuContext.checkedValues : props.checkedValues,
    defaultState: props.defaultCheckedValues,
    initialState: {}
  });
  const handleCheckedValueChange = hasMenuContext ? menuContext.onCheckedValueChange : props.onCheckedValueChange;
  const toggleCheckbox = react_utilities_1.useEventCallback((e, name, value, checked) => {
    const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
    const newCheckedItems = [...checkedItems];

    if (checked) {
      newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
    } else {
      newCheckedItems.push(value);
    }

    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {
      name,
      checkedItems: newCheckedItems
    });
    setCheckedValues(s => ({ ...s,
      [name]: newCheckedItems
    }));
  });
  const selectRadio = react_utilities_1.useEventCallback((e, name, value) => {
    const newCheckedItems = [value];
    setCheckedValues(s => ({ ...s,
      [name]: newCheckedItems
    }));
    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {
      name,
      checkedItems: newCheckedItems
    });
  });
  return {
    components: {
      root: 'div'
    },
    root: react_utilities_1.getNativeElementProps('div', {
      ref: react_utilities_1.useMergedRefs(ref, innerRef),
      role: 'menu',
      'aria-labelledby': menuContext.triggerId,
      ...focusAttributes,
      ...props
    }),
    hasIcons: menuContext.hasIcons || false,
    hasCheckmarks: menuContext.hasCheckmarks || false,
    checkedValues,
    setFocusByFirstCharacter,
    selectRadio,
    toggleCheckbox
  };
};

exports.useMenuList_unstable = useMenuList_unstable;
/**
 * Adds some sugar to fetching multiple context selector values
 */

const useMenuContextSelectors = () => {
  const checkedValues = menuContext_1.useMenuContext_unstable(context => context.checkedValues);
  const onCheckedValueChange = menuContext_1.useMenuContext_unstable(context => context.onCheckedValueChange);
  const triggerId = menuContext_1.useMenuContext_unstable(context => context.triggerId);
  const hasIcons = menuContext_1.useMenuContext_unstable(context => context.hasIcons);
  const hasCheckmarks = menuContext_1.useMenuContext_unstable(context => context.hasCheckmarks);
  return {
    checkedValues,
    onCheckedValueChange,
    triggerId,
    hasIcons,
    hasCheckmarks
  };
};
/**
 * Helper function to detect if props and MenuContext values are both used
 */


const usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {
  let isUsingPropsAndContext = false;

  for (const val in contextValue) {
    if (props[val]) {
      isUsingPropsAndContext = true;
    }
  }

  return hasMenuContext && isUsingPropsAndContext;
};
//# sourceMappingURL=useMenuList.js.map