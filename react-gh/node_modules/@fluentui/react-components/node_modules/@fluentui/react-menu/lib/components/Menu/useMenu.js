import * as React from 'react';
import { usePositioningMouseTarget, usePositioning, resolvePositioningShorthand } from '@fluentui/react-positioning';
import { useControllableState, useId, useOnClickOutside, useEventCallback, useOnScrollOutside } from '@fluentui/react-utilities';
import { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { elementContains } from '@fluentui/react-portal';
import { useFocusFinders } from '@fluentui/react-tabster';
import { useMenuContext_unstable } from '../../contexts/menuContext';
import { MENU_ENTER_EVENT, useOnMenuMouseEnter } from '../../utils/index';
import { useIsSubmenu } from '../../utils/useIsSubmenu';
import { Tab } from '@fluentui/keyboard-keys';
/**
 * Create the state required to render Menu.
 *
 * The returned state can be modified with hooks such as useMenuStyles,
 * before being passed to renderMenu_unstable.
 *
 * @param props - props from this instance of Menu
 */

export const useMenu_unstable = props => {
  const isSubmenu = useIsSubmenu();
  const {
    hoverDelay = 500,
    inline = false,
    hasCheckmarks = false,
    hasIcons = false,
    closeOnScroll = false,
    openOnContext = false,
    persistOnItemClick = false,
    openOnHover = isSubmenu,
    defaultCheckedValues
  } = props;
  const triggerId = useId('menu');
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const positioningState = {
    position: isSubmenu ? 'after' : 'below',
    align: isSubmenu ? 'top' : 'start',
    target: props.openOnContext ? contextTarget : undefined,
    ...resolvePositioningShorthand(props.positioning)
  };
  const children = React.Children.toArray(props.children);

  if (process.env.NODE_ENV !== 'production') {
    if (children.length === 0) {
      // eslint-disable-next-line no-console
      console.warn('Menu must contain at least one child');
    }

    if (children.length > 2) {
      // eslint-disable-next-line no-console
      console.warn('Menu must contain at most two children');
    }
  }

  let menuTrigger = undefined;
  let menuPopover = undefined;

  if (children.length === 2) {
    menuTrigger = children[0];
    menuPopover = children[1];
  } else if (children.length === 1) {
    menuPopover = children[0];
  }

  const {
    targetRef: triggerRef,
    containerRef: menuPopoverRef
  } = usePositioning(positioningState); // TODO Better way to narrow types ?

  const [open, setOpen] = useMenuOpenState({
    hoverDelay,
    isSubmenu,
    setContextTarget,
    closeOnScroll,
    menuPopoverRef,
    triggerRef,
    open: props.open,
    defaultOpen: props.defaultOpen,
    onOpenChange: props.onOpenChange,
    openOnContext
  });
  const [checkedValues, onCheckedValueChange] = useMenuSelectableState({
    checkedValues: props.checkedValues,
    defaultCheckedValues,
    onCheckedValueChange: props.onCheckedValueChange
  });
  return {
    inline,
    hoverDelay,
    triggerId,
    isSubmenu,
    openOnHover,
    contextTarget,
    setContextTarget,
    hasCheckmarks,
    hasIcons,
    closeOnScroll,
    menuTrigger,
    menuPopover,
    triggerRef,
    menuPopoverRef,
    components: {},
    openOnContext,
    open,
    setOpen,
    checkedValues,
    onCheckedValueChange,
    persistOnItemClick
  };
};
/**
 * Adds appropriate state values and handlers for selectable items
 * i.e checkboxes and radios
 */

const useMenuSelectableState = props => {
  const [checkedValues, setCheckedValues] = useControllableState({
    state: props.checkedValues,
    defaultState: props.defaultCheckedValues,
    initialState: {}
  });
  const onCheckedValueChange = useEventCallback((e, {
    name,
    checkedItems
  }) => {
    var _a;

    (_a = props.onCheckedValueChange) === null || _a === void 0 ? void 0 : _a.call(props, e, {
      name,
      checkedItems
    });
    setCheckedValues(currentValue => ({ ...currentValue,
      [name]: checkedItems
    }));
  });
  return [checkedValues, onCheckedValueChange];
};

const useMenuOpenState = state => {
  const {
    targetDocument
  } = useFluent();
  const parentSetOpen = useMenuContext_unstable(context => context.setOpen);
  const onOpenChange = useEventCallback((e, data) => {
    var _a;

    return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data);
  });
  const shouldHandleCloseRef = React.useRef(false);
  const shouldHandleTabRef = React.useRef(false);
  const pressedShiftRef = React.useRef(false);
  const setOpenTimeout = React.useRef(0);
  const enteringTriggerRef = React.useRef(false);
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  const trySetOpen = useEventCallback((e, data) => {
    const event = e instanceof CustomEvent && e.type === MENU_ENTER_EVENT ? e.detail.nativeEvent : e;
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, { ...data
    });

    if (data.open && e.type === 'contextmenu') {
      state.setContextTarget(e);
    }

    if (!data.open) {
      state.setContextTarget(undefined);
      shouldHandleCloseRef.current = true;
    }

    if (e.type === 'keydown') {
      if (e.key === Tab) {
        shouldHandleTabRef.current = true;
        pressedShiftRef.current = e.shiftKey;
      }
    }

    if (data.bubble) {
      parentSetOpen(e, { ...data
      });
    }

    setOpenState(data.open);
  });
  const setOpen = useEventCallback((e, data) => {
    var _a;

    clearTimeout(setOpenTimeout.current);

    if (!(e instanceof Event) && e.persist) {
      // < React 17 still uses pooled synthetic events
      e.persist();
    }

    if (e.type === 'mouseleave' || e.type === 'mouseenter' || e.type === 'mousemove' || e.type === MENU_ENTER_EVENT) {
      if ((_a = state.triggerRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
        enteringTriggerRef.current = e.type === 'mouseenter' || e.type === 'mousemove';
      } // FIXME leaking Node timeout type
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore


      setOpenTimeout.current = setTimeout(() => trySetOpen(e, data), state.hoverDelay);
    } else {
      trySetOpen(e, data);
    }
  });
  useOnClickOutside({
    contains: elementContains,
    disabled: !open,
    element: targetDocument,
    refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),
    callback: event => setOpen(event, {
      open: false,
      type: 'clickOutside',
      event
    })
  }); // only close on scroll for context, or when closeOnScroll is specified

  const closeOnScroll = state.openOnContext || state.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: event => setOpen(event, {
      open: false,
      type: 'scrollOutside',
      event
    }),
    refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),
    disabled: !open || !closeOnScroll
  });
  useOnMenuMouseEnter({
    element: targetDocument,
    callback: event => {
      // When moving from a menu directly back to its trigger, this handler can close the menu
      // Explicitly check a flag to see if this situation happens
      if (!enteringTriggerRef.current) {
        setOpen(event, {
          open: false,
          type: 'menuMouseEnter',
          event
        });
      }
    },
    disabled: !open,
    refs: [state.menuPopoverRef]
  }); // Clear timeout on unmount
  // Setting state after a component unmounts can cause memory leaks

  React.useEffect(() => {
    return () => {
      clearTimeout(setOpenTimeout.current);
    };
  }, []); // Manage focus for open state

  const {
    findFirstFocusable,
    findNextFocusable,
    findPrevFocusable
  } = useFocusFinders();
  const focusFirst = React.useCallback(() => {
    const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);
    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
  }, [findFirstFocusable, state.menuPopoverRef]);
  const focusAfterMenuTrigger = React.useCallback(() => {
    const nextFocusable = findNextFocusable(state.triggerRef.current);
    nextFocusable === null || nextFocusable === void 0 ? void 0 : nextFocusable.focus();
  }, [findNextFocusable, state.triggerRef]);
  const focusBeforeMenuTrigger = React.useCallback(() => {
    const prevFocusable = findPrevFocusable(state.triggerRef.current);
    prevFocusable === null || prevFocusable === void 0 ? void 0 : prevFocusable.focus();
  }, [findPrevFocusable, state.triggerRef]);
  React.useEffect(() => {
    var _a;

    if (open) {
      focusFirst();
    } else {
      if (shouldHandleCloseRef.current) {
        if (shouldHandleTabRef.current && !state.isSubmenu) {
          pressedShiftRef.current ? focusBeforeMenuTrigger() : focusAfterMenuTrigger();
        } else {
          (_a = state.triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
      }
    }

    shouldHandleCloseRef.current = false;
    shouldHandleTabRef.current = false;
    pressedShiftRef.current = false;
  }, [state.triggerRef, state.isSubmenu, open, focusFirst, focusAfterMenuTrigger, focusBeforeMenuTrigger]);
  return [open, setOpen];
};
//# sourceMappingURL=useMenu.js.map