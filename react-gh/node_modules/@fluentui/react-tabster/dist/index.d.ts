import type { GriffelStyle } from '@griffel/react';
import { makeResetStyles } from '@griffel/react';
import * as React_2 from 'react';
import type { RefObject } from 'react';
import { Types } from 'tabster';

/**
 * @internal
 * @param scope - Applies the ponyfill to all DOM children
 * @param win - window
 */
export declare function applyFocusVisiblePolyfill(scope: HTMLElement, win: Window): () => void;

/**
 * Creates a style for @see makeStyles that includes the necessary selectors for focus.
 * Should be used only when @see createFocusOutlineStyle does not fit requirements
 *
 * @param style - styling applied on focus, defaults to @see getDefaultFocusOutlineStyles
 * @param options - Configure the style of the focus outline
 */
export declare function createCustomFocusIndicatorStyle<TStyle extends GriffelStyle | GriffelResetStyle>(style: TStyle, { selector, enableOutline, }?: CreateCustomFocusIndicatorStyleOptions): TStyle extends GriffelStyle ? GriffelStyle : GriffelResetStyle;

export declare interface CreateCustomFocusIndicatorStyleOptions {
    selector?: 'focus' | 'focus-within';
    /**
     * Enables the browser default outline style
     * @default false
     */
    enableOutline?: boolean;
}

/**
 * NOTE: The element with the focus outline needs to have `position: relative` so that the
 * pseudo element can be properly positioned.
 *
 * @param options - Configure the style of the focus outline
 * @returns focus outline styles object for @see makeStyles
 */
export declare const createFocusOutlineStyle: ({ selector, style, }?: CreateFocusOutlineStyleOptions) => GriffelStyle;

export declare interface CreateFocusOutlineStyleOptions extends CreateCustomFocusIndicatorStyleOptions {
    style?: Partial<FocusOutlineStyleOptions>;
}

export declare type FocusOutlineOffset = Record<'top' | 'bottom' | 'left' | 'right', string>;

export declare type FocusOutlineStyleOptions = {
    /**
     * Only property not supported by the native CSS `outline`, if this is no longer needed
     * we can just go native instead
     */
    outlineRadius: string;
    outlineColor: string;
    outlineWidth: string;
    outlineOffset?: string | FocusOutlineOffset;
};

declare type GriffelResetStyle = Parameters<typeof makeResetStyles>[0];

/**
 * A hook that returns the necessary tabster attributes to support arrow key navigation
 * @param options - Options to configure keyboard navigation
 */
export declare const useArrowNavigationGroup: (options?: UseArrowNavigationGroupOptions) => Types.TabsterDOMAttribute;

export declare interface UseArrowNavigationGroupOptions {
    /**
     * Focus will navigate vertically, horizontally or in both directions (grid), defaults to horizontally
     * @defaultValue vertical
     */
    axis?: 'vertical' | 'horizontal' | 'grid' | 'both';
    /**
     * Focus will cycle to the first/last elements of the group without stopping
     */
    circular?: boolean;
    /**
     * Last focused element in the group will be remembered and focused (if still
     * available) when tabbing from outside of the group
     */
    memorizeCurrent?: boolean;
    /**
     * Allow tabbing within the arrow navigation group items.
     */
    tabbable?: boolean;
    /**
     * Tabster should ignore default handling of keydown events
     */
    ignoreDefaultKeydown?: Types.FocusableProps['ignoreKeydown'];
}

/**
 * A hook that returns the necessary tabster attributes to support groupping.
 * @param options - Options to configure keyboard navigation
 */
export declare const useFocusableGroup: (options?: UseFocusableGroupOptions | undefined) => Types.TabsterDOMAttribute;

export declare interface UseFocusableGroupOptions {
    /**
     * Behavior for the Tab key.
     */
    tabBehavior?: 'unlimited' | 'limited' | 'limited-trap-focus';
}

/**
 * Returns a set of helper functions that will traverse focusable elements in the context of a root DOM element
 */
export declare const useFocusFinders: () => {
    findAllFocusable: (container: HTMLElement, acceptCondition?: ((el: HTMLElement) => boolean) | undefined) => HTMLElement[];
    findFirstFocusable: (container: HTMLElement) => HTMLElement | null | undefined;
    findLastFocusable: (container: HTMLElement) => HTMLElement | null | undefined;
    findNextFocusable: (currentElement: HTMLElement, options?: Pick<Types.FindNextProps, 'container'>) => HTMLElement | null | undefined;
    findPrevFocusable: (currentElement: HTMLElement, options?: Pick<Types.FindNextProps, 'container'>) => HTMLElement | null | undefined;
};

export declare function useFocusVisible<TElement extends HTMLElement = HTMLElement>(): React_2.RefObject<TElement>;

/**
 * A ponyfill that allows `:focus-within` to support visibility based on keyboard/mouse navigation
 * like `:focus-visible` https://github.com/WICG/focus-visible/issues/151
 * @returns ref to the element that uses `:focus-within` styles
 */
export declare function useFocusWithin<TElement extends HTMLElement = HTMLElement>(): React_2.RefObject<TElement>;

/**
 * Instantiates [keyborg](https://github.com/microsoft/keyborg) and adds `data-keyboard-nav`
 * attribute to a referenced element to ensure keyboard navigation awareness
 * synced to keyborg logic without having to cause a re-render on react tree.
 */
export declare function useKeyboardNavAttribute<E extends HTMLElement>(): RefObject<E>;

/**
 * Applies modal dialog behaviour through DOM attributes
 * Modal element will focus trap and hide other content on the page
 * The trigger element will be focused if focus is lost after the modal element is removed
 *
 * @returns DOM attributes to apply to the modal element and its trigger
 */
export declare const useModalAttributes: (options?: UseModalAttributesOptions) => {
    modalAttributes: Types.TabsterDOMAttribute;
    triggerAttributes: Types.TabsterDOMAttribute;
};

export declare interface UseModalAttributesOptions {
    /**
     * Traps focus inside the elements the attributes are applied.
     * Prefer this to `legacyTrapFocus`
     * it forbids users to tab out of the focus trap into the actual browser.
     */
    trapFocus?: boolean;
    /**
     * Traps focus inside the elements the attributes are applied.
     * This prop enables legacy behavior to match previous versions of Fluent and is not
     * recommended for general use.
     * Enabling `legacyTrapFocus` prevents users from tabbing out of the focus trap and into
     * the actual browser. Prefer using `trapFocus` instead of this prop.
     */
    legacyTrapFocus?: boolean;
    /**
     * Always reachabled in Tab order
     */
    alwaysFocusable?: boolean;
}

/**
 * @internal
 * Hook that returns tabster attributes while ensuring tabster exists
 */
export declare const useTabsterAttributes: (props: Types.TabsterAttributeProps) => Types.TabsterDOMAttribute;

export { }
