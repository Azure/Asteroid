define(["require", "exports", "keyborg", "./constants"], function (require, exports, keyborg_1, constants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyFocusVisiblePolyfill = void 0;
    /**
     * @internal
     * @param scope - Applies the ponyfill to all DOM children
     * @param win - window
     */
    function applyFocusVisiblePolyfill(scope, win) {
        if (alreadyInScope(scope)) {
            // Focus visible polyfill already applied at this scope
            return function () { return undefined; };
        }
        var state = {
            current: undefined,
        };
        var keyborg = keyborg_1.createKeyborg(win);
        // When navigation mode changes remove the focus-visible selector
        keyborg.subscribe(function (isNavigatingWithKeyboard) {
            if (!isNavigatingWithKeyboard && state.current) {
                removeFocusVisibleClass(state.current);
                state.current = undefined;
            }
        });
        // Keyborg's focusin event is delegated so it's only registered once on the window
        // and contains metadata about the focus event
        var keyborgListener = function (e) {
            if (state.current) {
                removeFocusVisibleClass(state.current);
                state.current = undefined;
            }
            if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e.target) && e.target) {
                // Griffel can't create chained global styles so use the parent element for now
                state.current = e.target;
                applyFocusVisibleClass(state.current);
            }
        };
        // Make sure that when focus leaves the scope, the focus visible class is removed
        var blurListener = function (e) {
            if (!e.relatedTarget || (isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget))) {
                if (state.current) {
                    removeFocusVisibleClass(state.current);
                    state.current = undefined;
                }
            }
        };
        scope.addEventListener(keyborg_1.KEYBORG_FOCUSIN, keyborgListener);
        scope.addEventListener('focusout', blurListener);
        scope.focusVisible = true;
        // Return disposer
        return function () {
            scope.removeEventListener(keyborg_1.KEYBORG_FOCUSIN, keyborgListener);
            scope.removeEventListener('focusout', blurListener);
            delete scope.focusVisible;
            keyborg_1.disposeKeyborg(keyborg);
        };
    }
    exports.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;
    function applyFocusVisibleClass(el) {
        el.setAttribute(constants_1.FOCUS_VISIBLE_ATTR, '');
    }
    function removeFocusVisibleClass(el) {
        el.removeAttribute(constants_1.FOCUS_VISIBLE_ATTR);
    }
    function isHTMLElement(target) {
        if (!target) {
            return false;
        }
        return Boolean(target && typeof target === 'object' && 'classList' in target && 'contains' in target);
    }
    function alreadyInScope(el) {
        if (!el) {
            return false;
        }
        if (el.focusVisible) {
            return true;
        }
        return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
    }
});
//# sourceMappingURL=focusVisiblePolyfill.js.map