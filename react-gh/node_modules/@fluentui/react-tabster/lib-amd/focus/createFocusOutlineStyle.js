define(["require", "exports", "tslib", "@fluentui/react-theme", "@griffel/react", "./createCustomFocusIndicatorStyle", "./constants"], function (require, exports, tslib_1, react_theme_1, react_1, createCustomFocusIndicatorStyle_1, constants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFocusOutlineStyle = void 0;
    /**
     * NOTE: the element with the focus outline needs to have `position: relative` so that the
     * pseudo element can be properly positioned.
     *
     * @param options - Configures the style of the focus outline
     * @returns focus outline styles object
     */
    var getFocusOutlineStyles = function (options) {
        var _a, _b, _c, _d;
        var outlineRadius = options.outlineRadius, outlineColor = options.outlineColor, outlineOffset = options.outlineOffset, outlineWidth = options.outlineWidth;
        var outlineOffsetTop = ((_a = outlineOffset) === null || _a === void 0 ? void 0 : _a.top) || outlineOffset;
        var outlineOffsetBottom = ((_b = outlineOffset) === null || _b === void 0 ? void 0 : _b.bottom) || outlineOffset;
        var outlineOffsetLeft = ((_c = outlineOffset) === null || _c === void 0 ? void 0 : _c.left) || outlineOffset;
        var outlineOffsetRight = ((_d = outlineOffset) === null || _d === void 0 ? void 0 : _d.right) || outlineOffset;
        return tslib_1.__assign(tslib_1.__assign({}, react_1.shorthands.borderColor('transparent')), { '::after': tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ content: '""', position: 'absolute', pointerEvents: 'none', zIndex: 1 }, react_1.shorthands.borderStyle('solid')), react_1.shorthands.borderWidth(outlineWidth)), react_1.shorthands.borderRadius(outlineRadius)), react_1.shorthands.borderColor(outlineColor)), { top: !outlineOffset ? "-" + outlineWidth : "calc(0px - " + outlineWidth + " - " + outlineOffsetTop + ")", bottom: !outlineOffset ? "-" + outlineWidth : "calc(0px - " + outlineWidth + " - " + outlineOffsetBottom + ")", left: !outlineOffset ? "-" + outlineWidth : "calc(0px - " + outlineWidth + " - " + outlineOffsetLeft + ")", right: !outlineOffset ? "-" + outlineWidth : "calc(0px - " + outlineWidth + " - " + outlineOffsetRight + ")" }) });
    };
    /**
     * NOTE: The element with the focus outline needs to have `position: relative` so that the
     * pseudo element can be properly positioned.
     *
     * @param options - Configure the style of the focus outline
     * @returns focus outline styles object for @see makeStyles
     */
    var createFocusOutlineStyle = function (_a) {
        var _b = _a === void 0 ? constants_1.defaultOptions : _a, _c = _b.selector, selector = _c === void 0 ? constants_1.defaultOptions.selector : _c, _d = _b.style, style = _d === void 0 ? constants_1.defaultOptions.style : _d;
        return createCustomFocusIndicatorStyle_1.createCustomFocusIndicatorStyle(getFocusOutlineStyles(tslib_1.__assign({ outlineColor: react_theme_1.tokens.colorStrokeFocus2, outlineRadius: react_theme_1.tokens.borderRadiusMedium, 
            // FIXME: tokens.strokeWidthThick causes some weird bugs
            outlineWidth: '2px' }, style)), { selector: selector });
    };
    exports.createFocusOutlineStyle = createFocusOutlineStyle;
});
//# sourceMappingURL=createFocusOutlineStyle.js.map