"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMenuPopover_unstable = void 0;

const React = /*#__PURE__*/require("react");

const keyboard_keys_1 = /*#__PURE__*/require("@fluentui/keyboard-keys");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const menuContext_1 = /*#__PURE__*/require("../../contexts/menuContext");

const index_1 = /*#__PURE__*/require("../../utils/index");

const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");

const useIsSubmenu_1 = /*#__PURE__*/require("../../utils/useIsSubmenu");
/**
 * Create the state required to render MenuPopover.
 *
 * The returned state can be modified with hooks such as useMenuPopoverStyles_unstable,
 * before being passed to renderMenuPopover_unstable.
 *
 * @param props - props from this instance of MenuPopover
 * @param ref - reference to root HTMLElement of MenuPopover
 */


const useMenuPopover_unstable = (props, ref) => {
  var _a;

  const popoverRef = menuContext_1.useMenuContext_unstable(context => context.menuPopoverRef);
  const setOpen = menuContext_1.useMenuContext_unstable(context => context.setOpen);
  const open = menuContext_1.useMenuContext_unstable(context => context.open);
  const openOnHover = menuContext_1.useMenuContext_unstable(context => context.openOnHover);
  const isSubmenu = useIsSubmenu_1.useIsSubmenu();
  const canDispatchCustomEventRef = React.useRef(true);
  const throttleDispatchTimerRef = React.useRef(0);
  const {
    dir
  } = react_shared_contexts_1.useFluent_unstable();
  const CloseArrowKey = dir === 'ltr' ? keyboard_keys_1.ArrowLeft : keyboard_keys_1.ArrowRight; // use DOM listener since react events propagate up the react tree
  // no need to do `contains` logic as menus are all positioned in different portals

  const mouseOverListenerCallbackRef = React.useCallback(node => {
    if (node) {
      // Dispatches the custom menu mouse enter event with throttling
      // Needs to trigger on mouseover to support keyboard + mouse together
      // i.e. keyboard opens submenus while cursor is still on the parent
      node.addEventListener('mouseover', e => {
        if (canDispatchCustomEventRef.current) {
          canDispatchCustomEventRef.current = false;
          index_1.dispatchMenuEnterEvent(popoverRef.current, e); // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore #16889 Node setTimeout type leaking

          throttleDispatchTimerRef.current = setTimeout(() => canDispatchCustomEventRef.current = true, 250);
        }
      });
    }
  }, [popoverRef, throttleDispatchTimerRef]);
  React.useEffect(() => {
    () => clearTimeout(throttleDispatchTimerRef.current);
  }, []);
  const inline = (_a = menuContext_1.useMenuContext_unstable(context => context.inline)) !== null && _a !== void 0 ? _a : false;
  const rootProps = react_utilities_1.getNativeElementProps('div', {
    role: 'presentation',
    ...props,
    ref: react_utilities_1.useMergedRefs(ref, popoverRef, mouseOverListenerCallbackRef)
  });
  const {
    onMouseEnter: onMouseEnterOriginal,
    onKeyDown: onKeyDownOriginal
  } = rootProps;
  rootProps.onMouseEnter = react_utilities_1.useEventCallback(event => {
    if (openOnHover) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: 'menuPopoverMouseEnter',
        event
      });
    }

    onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(event);
  });
  rootProps.onKeyDown = react_utilities_1.useEventCallback(event => {
    var _a;

    const key = event.key;

    if (key === keyboard_keys_1.Escape || isSubmenu && key === CloseArrowKey) {
      if (open && ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {
        setOpen(event, {
          open: false,
          keyboard: true,
          type: 'menuPopoverKeyDown',
          event
        }); // stop propagation to avoid conflicting with other elements that listen for `Escape`
        // e,g: Dialog, Popover and Tooltip

        event.stopPropagation();
      }
    }

    if (key === keyboard_keys_1.Tab) {
      setOpen(event, {
        open: false,
        keyboard: true,
        type: 'menuPopoverKeyDown',
        event
      });
      event.preventDefault();
    }

    onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(event);
  });
  return {
    inline,
    components: {
      root: 'div'
    },
    root: rootProps
  };
};

exports.useMenuPopover_unstable = useMenuPopover_unstable;
//# sourceMappingURL=useMenuPopover.js.map