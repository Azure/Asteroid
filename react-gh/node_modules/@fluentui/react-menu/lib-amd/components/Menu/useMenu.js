define(["require", "exports", "tslib", "react", "@fluentui/react-positioning", "@fluentui/react-utilities", "@fluentui/react-shared-contexts", "@fluentui/react-portal", "@fluentui/react-tabster", "../../contexts/menuContext", "../../utils/index", "../../utils/useIsSubmenu", "@fluentui/keyboard-keys"], function (require, exports, tslib_1, React, react_positioning_1, react_utilities_1, react_shared_contexts_1, react_portal_1, react_tabster_1, menuContext_1, index_1, useIsSubmenu_1, keyboard_keys_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMenu_unstable = void 0;
    /**
     * Create the state required to render Menu.
     *
     * The returned state can be modified with hooks such as useMenuStyles,
     * before being passed to renderMenu_unstable.
     *
     * @param props - props from this instance of Menu
     */
    var useMenu_unstable = function (props) {
        var isSubmenu = useIsSubmenu_1.useIsSubmenu();
        var _a = props.hoverDelay, hoverDelay = _a === void 0 ? 500 : _a, _b = props.inline, inline = _b === void 0 ? false : _b, _c = props.hasCheckmarks, hasCheckmarks = _c === void 0 ? false : _c, _d = props.hasIcons, hasIcons = _d === void 0 ? false : _d, _e = props.closeOnScroll, closeOnScroll = _e === void 0 ? false : _e, _f = props.openOnContext, openOnContext = _f === void 0 ? false : _f, _g = props.persistOnItemClick, persistOnItemClick = _g === void 0 ? false : _g, _h = props.openOnHover, openOnHover = _h === void 0 ? isSubmenu : _h, defaultCheckedValues = props.defaultCheckedValues;
        var triggerId = react_utilities_1.useId('menu');
        var _j = react_positioning_1.usePositioningMouseTarget(), contextTarget = _j[0], setContextTarget = _j[1];
        var positioningState = tslib_1.__assign({ position: isSubmenu ? 'after' : 'below', align: isSubmenu ? 'top' : 'start', target: props.openOnContext ? contextTarget : undefined }, react_positioning_1.resolvePositioningShorthand(props.positioning));
        var children = React.Children.toArray(props.children);
        if (process.env.NODE_ENV !== 'production') {
            if (children.length === 0) {
                // eslint-disable-next-line no-console
                console.warn('Menu must contain at least one child');
            }
            if (children.length > 2) {
                // eslint-disable-next-line no-console
                console.warn('Menu must contain at most two children');
            }
        }
        var menuTrigger = undefined;
        var menuPopover = undefined;
        if (children.length === 2) {
            menuTrigger = children[0];
            menuPopover = children[1];
        }
        else if (children.length === 1) {
            menuPopover = children[0];
        }
        var _k = react_positioning_1.usePositioning(positioningState), triggerRef = _k.targetRef, menuPopoverRef = _k.containerRef;
        // TODO Better way to narrow types ?
        var _l = useMenuOpenState({
            hoverDelay: hoverDelay,
            isSubmenu: isSubmenu,
            setContextTarget: setContextTarget,
            closeOnScroll: closeOnScroll,
            menuPopoverRef: menuPopoverRef,
            triggerRef: triggerRef,
            open: props.open,
            defaultOpen: props.defaultOpen,
            onOpenChange: props.onOpenChange,
            openOnContext: openOnContext,
        }), open = _l[0], setOpen = _l[1];
        var _m = useMenuSelectableState({
            checkedValues: props.checkedValues,
            defaultCheckedValues: defaultCheckedValues,
            onCheckedValueChange: props.onCheckedValueChange,
        }), checkedValues = _m[0], onCheckedValueChange = _m[1];
        return {
            inline: inline,
            hoverDelay: hoverDelay,
            triggerId: triggerId,
            isSubmenu: isSubmenu,
            openOnHover: openOnHover,
            contextTarget: contextTarget,
            setContextTarget: setContextTarget,
            hasCheckmarks: hasCheckmarks,
            hasIcons: hasIcons,
            closeOnScroll: closeOnScroll,
            menuTrigger: menuTrigger,
            menuPopover: menuPopover,
            triggerRef: triggerRef,
            menuPopoverRef: menuPopoverRef,
            components: {},
            openOnContext: openOnContext,
            open: open,
            setOpen: setOpen,
            checkedValues: checkedValues,
            onCheckedValueChange: onCheckedValueChange,
            persistOnItemClick: persistOnItemClick,
        };
    };
    exports.useMenu_unstable = useMenu_unstable;
    /**
     * Adds appropriate state values and handlers for selectable items
     * i.e checkboxes and radios
     */
    var useMenuSelectableState = function (props) {
        var _a = react_utilities_1.useControllableState({
            state: props.checkedValues,
            defaultState: props.defaultCheckedValues,
            initialState: {},
        }), checkedValues = _a[0], setCheckedValues = _a[1];
        var onCheckedValueChange = react_utilities_1.useEventCallback(function (e, _a) {
            var _b;
            var name = _a.name, checkedItems = _a.checkedItems;
            (_b = props.onCheckedValueChange) === null || _b === void 0 ? void 0 : _b.call(props, e, { name: name, checkedItems: checkedItems });
            setCheckedValues(function (currentValue) {
                var _a;
                return (tslib_1.__assign(tslib_1.__assign({}, currentValue), (_a = {}, _a[name] = checkedItems, _a)));
            });
        });
        return [checkedValues, onCheckedValueChange];
    };
    var useMenuOpenState = function (state) {
        var targetDocument = react_shared_contexts_1.useFluent_unstable().targetDocument;
        var parentSetOpen = menuContext_1.useMenuContext_unstable(function (context) { return context.setOpen; });
        var onOpenChange = react_utilities_1.useEventCallback(function (e, data) { var _a; return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data); });
        var shouldHandleCloseRef = React.useRef(false);
        var shouldHandleTabRef = React.useRef(false);
        var pressedShiftRef = React.useRef(false);
        var setOpenTimeout = React.useRef(0);
        var enteringTriggerRef = React.useRef(false);
        var _a = react_utilities_1.useControllableState({
            state: state.open,
            defaultState: state.defaultOpen,
            initialState: false,
        }), open = _a[0], setOpenState = _a[1];
        var trySetOpen = react_utilities_1.useEventCallback(function (e, data) {
            var event = e instanceof CustomEvent && e.type === index_1.MENU_ENTER_EVENT ? e.detail.nativeEvent : e;
            onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, tslib_1.__assign({}, data));
            if (data.open && e.type === 'contextmenu') {
                state.setContextTarget(e);
            }
            if (!data.open) {
                state.setContextTarget(undefined);
                shouldHandleCloseRef.current = true;
            }
            if (e.type === 'keydown') {
                if (e.key === keyboard_keys_1.Tab) {
                    shouldHandleTabRef.current = true;
                    pressedShiftRef.current = e.shiftKey;
                }
            }
            if (data.bubble) {
                parentSetOpen(e, tslib_1.__assign({}, data));
            }
            setOpenState(data.open);
        });
        var setOpen = react_utilities_1.useEventCallback(function (e, data) {
            var _a;
            clearTimeout(setOpenTimeout.current);
            if (!(e instanceof Event) && e.persist) {
                // < React 17 still uses pooled synthetic events
                e.persist();
            }
            if (e.type === 'mouseleave' || e.type === 'mouseenter' || e.type === 'mousemove' || e.type === index_1.MENU_ENTER_EVENT) {
                if ((_a = state.triggerRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
                    enteringTriggerRef.current = e.type === 'mouseenter' || e.type === 'mousemove';
                }
                // FIXME leaking Node timeout type
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                setOpenTimeout.current = setTimeout(function () { return trySetOpen(e, data); }, state.hoverDelay);
            }
            else {
                trySetOpen(e, data);
            }
        });
        react_utilities_1.useOnClickOutside({
            contains: react_portal_1.elementContains,
            disabled: !open,
            element: targetDocument,
            refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),
            callback: function (event) { return setOpen(event, { open: false, type: 'clickOutside', event: event }); },
        });
        // only close on scroll for context, or when closeOnScroll is specified
        var closeOnScroll = state.openOnContext || state.closeOnScroll;
        react_utilities_1.useOnScrollOutside({
            contains: react_portal_1.elementContains,
            element: targetDocument,
            callback: function (event) { return setOpen(event, { open: false, type: 'scrollOutside', event: event }); },
            refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),
            disabled: !open || !closeOnScroll,
        });
        index_1.useOnMenuMouseEnter({
            element: targetDocument,
            callback: function (event) {
                // When moving from a menu directly back to its trigger, this handler can close the menu
                // Explicitly check a flag to see if this situation happens
                if (!enteringTriggerRef.current) {
                    setOpen(event, { open: false, type: 'menuMouseEnter', event: event });
                }
            },
            disabled: !open,
            refs: [state.menuPopoverRef],
        });
        // Clear timeout on unmount
        // Setting state after a component unmounts can cause memory leaks
        React.useEffect(function () {
            return function () {
                clearTimeout(setOpenTimeout.current);
            };
        }, []);
        // Manage focus for open state
        var _b = react_tabster_1.useFocusFinders(), findFirstFocusable = _b.findFirstFocusable, findNextFocusable = _b.findNextFocusable, findPrevFocusable = _b.findPrevFocusable;
        var focusFirst = React.useCallback(function () {
            var firstFocusable = findFirstFocusable(state.menuPopoverRef.current);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
        }, [findFirstFocusable, state.menuPopoverRef]);
        var focusAfterMenuTrigger = React.useCallback(function () {
            var nextFocusable = findNextFocusable(state.triggerRef.current);
            nextFocusable === null || nextFocusable === void 0 ? void 0 : nextFocusable.focus();
        }, [findNextFocusable, state.triggerRef]);
        var focusBeforeMenuTrigger = React.useCallback(function () {
            var prevFocusable = findPrevFocusable(state.triggerRef.current);
            prevFocusable === null || prevFocusable === void 0 ? void 0 : prevFocusable.focus();
        }, [findPrevFocusable, state.triggerRef]);
        React.useEffect(function () {
            var _a;
            if (open) {
                focusFirst();
            }
            else {
                if (shouldHandleCloseRef.current) {
                    if (shouldHandleTabRef.current && !state.isSubmenu) {
                        pressedShiftRef.current ? focusBeforeMenuTrigger() : focusAfterMenuTrigger();
                    }
                    else {
                        (_a = state.triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                    }
                }
            }
            shouldHandleCloseRef.current = false;
            shouldHandleTabRef.current = false;
            pressedShiftRef.current = false;
        }, [state.triggerRef, state.isSubmenu, open, focusFirst, focusAfterMenuTrigger, focusBeforeMenuTrigger]);
        return [open, setOpen];
    };
});
//# sourceMappingURL=useMenu.js.map