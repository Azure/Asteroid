define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/react-tabster", "@fluentui/react-context-selector", "../../contexts/menuContext", "../../contexts/menuContext"], function (require, exports, tslib_1, React, react_utilities_1, react_tabster_1, react_context_selector_1, menuContext_1, menuContext_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMenuList_unstable = void 0;
    /**
     * Returns the props and state required to render the component
     */
    var useMenuList_unstable = function (props, ref) {
        var focusAttributes = react_tabster_1.useArrowNavigationGroup({ circular: true, ignoreDefaultKeydown: { Tab: true } });
        var findAllFocusable = react_tabster_1.useFocusFinders().findAllFocusable;
        var menuContext = useMenuContextSelectors();
        var hasMenuContext = react_context_selector_1.useHasParentContext(menuContext_2.MenuContext);
        if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {
            // TODO throw warnings in development safely
            // eslint-disable-next-line no-console
            console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');
        }
        var innerRef = React.useRef(null);
        var setFocusByFirstCharacter = React.useCallback(function (e, itemEl) {
            // TODO use some kind of children registration to reduce dependency on DOM roles
            var acceptedRoles = ['menuitem', 'menuitemcheckbox', 'menuitemradio'];
            if (!innerRef.current) {
                return;
            }
            var menuItems = findAllFocusable(innerRef.current, function (el) { return el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')) !== -1; });
            var startIndex = menuItems.indexOf(itemEl) + 1;
            if (startIndex === menuItems.length) {
                startIndex = 0;
            }
            var firstChars = menuItems.map(function (menuItem) { var _a; return (_a = menuItem.textContent) === null || _a === void 0 ? void 0 : _a.charAt(0).toLowerCase(); });
            var char = e.key.toLowerCase();
            var getIndexFirstChars = function (start, firstChar) {
                for (var i = start; i < firstChars.length; i++) {
                    if (char === firstChars[i]) {
                        return i;
                    }
                }
                return -1;
            };
            // Check remaining slots in the menu
            var index = getIndexFirstChars(startIndex, char);
            // If not found in remaining slots, check from beginning
            if (index === -1) {
                index = getIndexFirstChars(0, char);
            }
            // If match was found...
            if (index > -1) {
                menuItems[index].focus();
            }
        }, [findAllFocusable]);
        var _a = react_utilities_1.useControllableState({
            state: hasMenuContext ? menuContext.checkedValues : props.checkedValues,
            defaultState: props.defaultCheckedValues,
            initialState: {},
        }), checkedValues = _a[0], setCheckedValues = _a[1];
        var handleCheckedValueChange = hasMenuContext ? menuContext.onCheckedValueChange : props.onCheckedValueChange;
        var toggleCheckbox = react_utilities_1.useEventCallback(function (e, name, value, checked) {
            var checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
            var newCheckedItems = tslib_1.__spreadArray([], checkedItems);
            if (checked) {
                newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
            }
            else {
                newCheckedItems.push(value);
            }
            handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, { name: name, checkedItems: newCheckedItems });
            setCheckedValues(function (s) {
                var _a;
                return (tslib_1.__assign(tslib_1.__assign({}, s), (_a = {}, _a[name] = newCheckedItems, _a)));
            });
        });
        var selectRadio = react_utilities_1.useEventCallback(function (e, name, value) {
            var newCheckedItems = [value];
            setCheckedValues(function (s) {
                var _a;
                return (tslib_1.__assign(tslib_1.__assign({}, s), (_a = {}, _a[name] = newCheckedItems, _a)));
            });
            handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, { name: name, checkedItems: newCheckedItems });
        });
        return {
            components: {
                root: 'div',
            },
            root: react_utilities_1.getNativeElementProps('div', tslib_1.__assign(tslib_1.__assign({ ref: react_utilities_1.useMergedRefs(ref, innerRef), role: 'menu', 'aria-labelledby': menuContext.triggerId }, focusAttributes), props)),
            hasIcons: menuContext.hasIcons || false,
            hasCheckmarks: menuContext.hasCheckmarks || false,
            checkedValues: checkedValues,
            setFocusByFirstCharacter: setFocusByFirstCharacter,
            selectRadio: selectRadio,
            toggleCheckbox: toggleCheckbox,
        };
    };
    exports.useMenuList_unstable = useMenuList_unstable;
    /**
     * Adds some sugar to fetching multiple context selector values
     */
    var useMenuContextSelectors = function () {
        var checkedValues = menuContext_1.useMenuContext_unstable(function (context) { return context.checkedValues; });
        var onCheckedValueChange = menuContext_1.useMenuContext_unstable(function (context) { return context.onCheckedValueChange; });
        var triggerId = menuContext_1.useMenuContext_unstable(function (context) { return context.triggerId; });
        var hasIcons = menuContext_1.useMenuContext_unstable(function (context) { return context.hasIcons; });
        var hasCheckmarks = menuContext_1.useMenuContext_unstable(function (context) { return context.hasCheckmarks; });
        return {
            checkedValues: checkedValues,
            onCheckedValueChange: onCheckedValueChange,
            triggerId: triggerId,
            hasIcons: hasIcons,
            hasCheckmarks: hasCheckmarks,
        };
    };
    /**
     * Helper function to detect if props and MenuContext values are both used
     */
    var usingPropsAndMenuContext = function (props, contextValue, hasMenuContext) {
        var isUsingPropsAndContext = false;
        for (var val in contextValue) {
            if (props[val]) {
                isUsingPropsAndContext = true;
            }
        }
        return hasMenuContext && isUsingPropsAndContext;
    };
});
//# sourceMappingURL=useMenuList.js.map