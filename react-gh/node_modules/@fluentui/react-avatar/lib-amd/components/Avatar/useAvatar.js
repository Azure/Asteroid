define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "../../utils/index", "@fluentui/react-icons", "@fluentui/react-badge", "@fluentui/react-shared-contexts", "../../contexts/AvatarContext"], function (require, exports, tslib_1, React, react_utilities_1, index_1, react_icons_1, react_badge_1, react_shared_contexts_1, AvatarContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAvatar_unstable = exports.DEFAULT_STRINGS = void 0;
    exports.DEFAULT_STRINGS = {
        active: 'active',
        inactive: 'inactive',
    };
    var useAvatar_unstable = function (props, ref) {
        var _a;
        var dir = react_shared_contexts_1.useFluent_unstable().dir;
        var contextSize = AvatarContext_1.useAvatarContext().size;
        var name = props.name, _b = props.size, size = _b === void 0 ? contextSize !== null && contextSize !== void 0 ? contextSize : 32 : _b, _c = props.shape, shape = _c === void 0 ? 'circular' : _c, _d = props.active, active = _d === void 0 ? 'unset' : _d, _e = props.activeAppearance, activeAppearance = _e === void 0 ? 'ring' : _e, idForColor = props.idForColor;
        var _f = props.color, color = _f === void 0 ? 'neutral' : _f;
        // Resolve 'colorful' to a specific color name
        if (color === 'colorful') {
            color = avatarColors[getHashCode((_a = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _a !== void 0 ? _a : '') % avatarColors.length];
        }
        var baseId = react_utilities_1.useId('avatar-');
        var root = react_utilities_1.getNativeElementProps('span', tslib_1.__assign(tslib_1.__assign({ role: 'img', id: baseId }, props), { ref: ref }), 
        /* excludedPropNames: */ ['name']);
        var _g = React.useState(undefined), imageHidden = _g[0], setImageHidden = _g[1];
        var image = react_utilities_1.resolveShorthand(props.image, {
            defaultProps: {
                alt: '',
                role: 'presentation',
                'aria-hidden': true,
                hidden: imageHidden,
            },
        });
        // Hide the image if it fails to load and restore it on a successful load
        if (image) {
            image.onError = react_utilities_1.mergeCallbacks(image.onError, function () { return setImageHidden(true); });
            image.onLoad = react_utilities_1.mergeCallbacks(image.onLoad, function () { return setImageHidden(undefined); });
        }
        // Resolve the initials slot, defaulted to getInitials.
        var initials = react_utilities_1.resolveShorthand(props.initials, {
            required: true,
            defaultProps: {
                children: index_1.getInitials(name, dir === 'rtl', { firstInitialOnly: size <= 16 }),
                id: baseId + '__initials',
            },
        });
        // Don't render the initials slot if it's empty
        if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
            initials = undefined;
        }
        // Render the icon slot *only if* there aren't any initials or image to display
        var icon = undefined;
        if (!initials && (!image || imageHidden)) {
            icon = react_utilities_1.resolveShorthand(props.icon, {
                required: true,
                defaultProps: {
                    children: React.createElement(react_icons_1.PersonRegular, null),
                    'aria-hidden': true,
                },
            });
        }
        var badge = react_utilities_1.resolveShorthand(props.badge, {
            defaultProps: {
                size: getBadgeSize(size),
                id: baseId + '__badge',
            },
        });
        var activeAriaLabelElement;
        // Resolve aria-label and/or aria-labelledby if not provided by the user
        if (!root['aria-label'] && !root['aria-labelledby']) {
            if (name) {
                root['aria-label'] = name;
                // Include the badge in labelledby if it exists
                if (badge) {
                    root['aria-labelledby'] = root.id + ' ' + badge.id;
                }
            }
            else if (initials) {
                // root's aria-label should be the name, but fall back to being labelledby the initials if name is missing
                root['aria-labelledby'] = initials.id + (badge ? ' ' + badge.id : '');
            }
            // Add the active state to the aria label
            if (active === 'active' || active === 'inactive') {
                var activeText = exports.DEFAULT_STRINGS[active];
                if (root['aria-labelledby']) {
                    // If using aria-labelledby, render a hidden span and append it to the labelledby
                    var activeId = baseId + '__active';
                    root['aria-labelledby'] += ' ' + activeId;
                    activeAriaLabelElement = (React.createElement("span", { hidden: true, id: activeId }, activeText));
                }
                else if (root['aria-label']) {
                    // Otherwise, just append it to the aria-label
                    root['aria-label'] += ' ' + activeText;
                }
            }
        }
        return {
            size: size,
            shape: shape,
            active: active,
            activeAppearance: activeAppearance,
            activeAriaLabelElement: activeAriaLabelElement,
            color: color,
            components: {
                root: 'span',
                initials: 'span',
                icon: 'span',
                image: 'img',
                badge: react_badge_1.PresenceBadge,
            },
            root: root,
            initials: initials,
            icon: icon,
            image: image,
            badge: badge,
        };
    };
    exports.useAvatar_unstable = useAvatar_unstable;
    var getBadgeSize = function (size) {
        if (size >= 96) {
            return 'extra-large';
        }
        else if (size >= 64) {
            return 'large';
        }
        else if (size >= 56) {
            return 'medium';
        }
        else if (size >= 40) {
            return 'small';
        }
        else if (size >= 28) {
            return 'extra-small';
        }
        else {
            return 'tiny';
        }
    };
    var avatarColors = [
        'dark-red',
        'cranberry',
        'red',
        'pumpkin',
        'peach',
        'marigold',
        'gold',
        'brass',
        'brown',
        'forest',
        'seafoam',
        'dark-green',
        'light-teal',
        'teal',
        'steel',
        'blue',
        'royal-blue',
        'cornflower',
        'navy',
        'lavender',
        'purple',
        'grape',
        'lilac',
        'pink',
        'magenta',
        'plum',
        'beige',
        'mink',
        'platinum',
        'anchor',
    ];
    var getHashCode = function (str) {
        var hashCode = 0;
        for (var len = str.length - 1; len >= 0; len--) {
            var ch = str.charCodeAt(len);
            var shift = len % 8;
            hashCode ^= (ch << shift) + (ch >> (8 - shift)); // eslint-disable-line no-bitwise
        }
        return hashCode;
    };
});
//# sourceMappingURL=useAvatar.js.map