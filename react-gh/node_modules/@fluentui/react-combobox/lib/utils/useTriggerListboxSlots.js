import * as React from 'react';
import { mergeCallbacks, useMergedRefs } from '@fluentui/react-utilities';
import { getDropdownActionFromKey, getIndexFromAction } from '../utils/dropdownKeyActions';
/*
 * useTriggerListboxSlots returns a tuple of trigger/listbox shorthand,
 * with the semantics and event handlers needed for the Combobox and Dropdown components.
 * The element type of the ref should always match the element type used in the trigger shorthand.
 */

export function useTriggerListboxSlots(props, state, ref, triggerSlot, listboxSlot) {
  const {
    multiselect
  } = props;
  const {
    activeOption,
    getCount,
    getIndexOfId,
    getOptionAtIndex,
    ignoreNextBlur,
    open,
    selectOption,
    setActiveOption,
    setFocusVisible,
    setHasFocus,
    setOpen
  } = state; // handle trigger focus/blur

  const triggerRef = React.useRef(null); // resolve listbox shorthand props

  const listbox = listboxSlot && {
    multiselect,
    tabIndex: undefined,
    ...listboxSlot
  }; // resolve trigger shorthand props

  const trigger = {
    'aria-expanded': open,
    'aria-activedescendant': open ? activeOption === null || activeOption === void 0 ? void 0 : activeOption.id : undefined,
    role: 'combobox',
    ...triggerSlot,
    // explicitly type the ref as an intersection here to prevent type errors
    // since the `children` prop has mutually incompatible types between input/button
    // functionally both ref and triggerRef will always be the same element type
    ref: useMergedRefs(ref, triggerSlot === null || triggerSlot === void 0 ? void 0 : triggerSlot.ref, triggerRef)
  }; // listbox is nullable, only add event handlers if it exists

  if (listbox) {
    /*
     * Handle focus when clicking the listbox popup:
     * 1. Move focus back to the button/input when the listbox is clicked (otherwise it goes to body)
     * 2. Do not close the listbox on button/input blur when clicking into the listbox
     */
    listbox.onClick = mergeCallbacks(event => {
      var _a;

      (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, listbox.onClick);
    listbox.onMouseOver = mergeCallbacks(event => {
      setFocusVisible(false);
    }, listbox.onMouseOver);
    listbox.onMouseDown = mergeCallbacks(event => {
      ignoreNextBlur.current = true;
    }, listbox.onMouseDown);
  } // the trigger should open/close the popup on click or blur


  trigger.onBlur = mergeCallbacks(event => {
    if (!ignoreNextBlur.current) {
      setOpen(event, false);
    }

    ignoreNextBlur.current = false;
    setHasFocus(false);
  }, trigger.onBlur);
  trigger.onClick = mergeCallbacks(event => {
    setOpen(event, !open);
  }, trigger.onClick);
  trigger.onFocus = mergeCallbacks(event => {
    setHasFocus(true);
  }, trigger.onFocus); // handle combobox keyboard interaction

  trigger.onKeyDown = mergeCallbacks(event => {
    const action = getDropdownActionFromKey(event, {
      open,
      multiselect
    });
    const maxIndex = getCount() - 1;
    const activeIndex = activeOption ? getIndexOfId(activeOption.id) : -1;
    let newIndex = activeIndex;

    switch (action) {
      case 'Open':
        event.preventDefault();
        setFocusVisible(true);
        setOpen(event, true);
        break;

      case 'Close':
        // stop propagation for escape key to avoid dismissing any parent popups
        event.stopPropagation();
        event.preventDefault();
        setOpen(event, false);
        break;

      case 'CloseSelect':
        !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(event, false);
      // fallthrough

      case 'Select':
        activeOption && selectOption(event, activeOption);
        event.preventDefault();
        break;

      case 'Tab':
        !multiselect && activeOption && selectOption(event, activeOption);
        break;

      default:
        newIndex = getIndexFromAction(action, activeIndex, maxIndex);
    }

    if (newIndex !== activeIndex) {
      // prevent default page scroll/keyboard action if the index changed
      event.preventDefault();
      setActiveOption(getOptionAtIndex(newIndex));
      setFocusVisible(true);
    }
  }, trigger.onKeyDown);
  trigger.onMouseOver = mergeCallbacks(event => {
    setFocusVisible(false);
  }, trigger.onMouseOver);
  return [trigger, listbox];
}
//# sourceMappingURL=useTriggerListboxSlots.js.map