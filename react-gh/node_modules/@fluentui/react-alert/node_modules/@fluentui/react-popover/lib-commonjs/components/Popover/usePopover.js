"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePopover_unstable = void 0;

const React = /*#__PURE__*/require("react");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts");

const react_positioning_1 = /*#__PURE__*/require("@fluentui/react-positioning");

const react_portal_1 = /*#__PURE__*/require("@fluentui/react-portal");

const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");

const index_1 = /*#__PURE__*/require("../PopoverSurface/index");

const constants_1 = /*#__PURE__*/require("./constants");
/**
 * Create the state required to render Popover.
 *
 * The returned state can be modified with hooks such as usePopoverStyles,
 * before being passed to renderPopover_unstable.
 *
 * @param props - props from this instance of Popover
 */


const usePopover_unstable = props => {
  var _a;

  const [contextTarget, setContextTarget] = react_positioning_1.usePositioningMouseTarget();
  const initialState = {
    size: 'medium',
    contextTarget,
    setContextTarget,
    ...props
  };
  const children = React.Children.toArray(props.children);

  if (process.env.NODE_ENV !== 'production') {
    if (children.length === 0) {
      // eslint-disable-next-line no-console
      console.warn('Popover must contain at least one child');
    }

    if (children.length > 2) {
      // eslint-disable-next-line no-console
      console.warn('Popover must contain at most two children');
    }
  }

  let popoverTrigger = undefined;
  let popoverSurface = undefined;

  if (children.length === 2) {
    popoverTrigger = children[0];
    popoverSurface = children[1];
  } else if (children.length === 1) {
    popoverSurface = children[0];
  }

  const [open, setOpenState] = useOpenState(initialState);
  const setOpenTimeoutRef = React.useRef(0);
  const setOpen = react_utilities_1.useEventCallback((e, shouldOpen) => {
    var _a;

    clearTimeout(setOpenTimeoutRef.current);

    if (!(e instanceof Event) && e.persist) {
      // < React 17 still uses pooled synthetic events
      e.persist();
    }

    if (e.type === 'mouseleave') {
      // FIXME leaking Node timeout type
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      setOpenTimeoutRef.current = setTimeout(() => {
        setOpenState(e, shouldOpen);
      }, (_a = props.mouseLeaveDelay) !== null && _a !== void 0 ? _a : 500);
    } else {
      setOpenState(e, shouldOpen);
    }
  }); // Clear timeout on unmount
  // Setting state after a component unmounts can cause memory leaks

  React.useEffect(() => {
    return () => {
      clearTimeout(setOpenTimeoutRef.current);
    };
  }, []);
  const toggleOpen = React.useCallback(e => {
    setOpen(e, !open);
  }, [setOpen, open]);
  const positioningRefs = usePopoverRefs(initialState);
  const {
    targetDocument
  } = react_shared_contexts_1.useFluent_unstable();
  react_utilities_1.useOnClickOutside({
    contains: react_portal_1.elementContains,
    element: targetDocument,
    callback: ev => setOpen(ev, false),
    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
    disabled: !open
  }); // only close on scroll for context, or when closeOnScroll is specified

  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
  react_utilities_1.useOnScrollOutside({
    contains: react_portal_1.elementContains,
    element: targetDocument,
    callback: ev => setOpen(ev, false),
    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
    disabled: !open || !closeOnScroll
  });
  const {
    findFirstFocusable
  } = react_tabster_1.useFocusFinders();
  React.useEffect(() => {
    var _a;

    if (open && positioningRefs.contentRef.current) {
      const containerTabIndex = (_a = positioningRefs.contentRef.current.getAttribute('tabIndex')) !== null && _a !== void 0 ? _a : undefined;
      const firstFocusable = isNaN(containerTabIndex) ? findFirstFocusable(positioningRefs.contentRef.current) : positioningRefs.contentRef.current;
      firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
    }
  }, [findFirstFocusable, open, positioningRefs.contentRef]);
  return { ...initialState,
    ...positioningRefs,
    popoverTrigger,
    popoverSurface,
    open,
    setOpen,
    toggleOpen,
    setContextTarget,
    contextTarget,
    inline: (_a = props.inline) !== null && _a !== void 0 ? _a : false
  };
};

exports.usePopover_unstable = usePopover_unstable;
/**
 * Creates and manages the Popover open state
 */

function useOpenState(state) {
  const onOpenChange = react_utilities_1.useEventCallback((e, data) => {
    var _a;

    return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data);
  });
  const [open, setOpenState] = react_utilities_1.useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  state.open = open !== undefined ? open : state.open;
  const setContextTarget = state.setContextTarget;
  const setOpen = React.useCallback((e, shouldOpen) => {
    if (shouldOpen && e.type === 'contextmenu') {
      setContextTarget(e);
    }

    if (!shouldOpen) {
      setContextTarget(undefined);
    }

    setOpenState(shouldOpen);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, {
      open: shouldOpen
    });
  }, [setOpenState, onOpenChange, setContextTarget]);
  return [open, setOpen];
}
/**
 * Creates and sets the necessary trigger, target and content refs used by Popover
 */


function usePopoverRefs(state) {
  const positioningOptions = {
    position: 'above',
    align: 'center',
    arrowPadding: 2 * constants_1.popoverSurfaceBorderRadius,
    target: state.openOnContext ? state.contextTarget : undefined,
    ...react_positioning_1.resolvePositioningShorthand(state.positioning)
  }; // no reason to render arrow when covering the target

  if (positioningOptions.coverTarget) {
    state.withArrow = false;
  }

  if (state.withArrow) {
    positioningOptions.offset = react_positioning_1.mergeArrowOffset(positioningOptions.offset, index_1.arrowHeights[state.size]);
  }

  const {
    targetRef: triggerRef,
    containerRef: contentRef,
    arrowRef
  } = react_positioning_1.usePositioning(positioningOptions);
  return {
    triggerRef,
    contentRef,
    arrowRef
  };
}
//# sourceMappingURL=usePopover.js.map