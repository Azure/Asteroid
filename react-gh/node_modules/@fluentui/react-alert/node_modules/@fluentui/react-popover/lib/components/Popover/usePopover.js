import * as React from 'react';
import { useControllableState, useEventCallback, useOnClickOutside, useOnScrollOutside } from '@fluentui/react-utilities';
import { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { usePositioning, resolvePositioningShorthand, mergeArrowOffset, usePositioningMouseTarget } from '@fluentui/react-positioning';
import { elementContains } from '@fluentui/react-portal';
import { useFocusFinders } from '@fluentui/react-tabster';
import { arrowHeights } from '../PopoverSurface/index';
import { popoverSurfaceBorderRadius } from './constants';
/**
 * Create the state required to render Popover.
 *
 * The returned state can be modified with hooks such as usePopoverStyles,
 * before being passed to renderPopover_unstable.
 *
 * @param props - props from this instance of Popover
 */

export const usePopover_unstable = props => {
  var _a;

  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const initialState = {
    size: 'medium',
    contextTarget,
    setContextTarget,
    ...props
  };
  const children = React.Children.toArray(props.children);

  if (process.env.NODE_ENV !== 'production') {
    if (children.length === 0) {
      // eslint-disable-next-line no-console
      console.warn('Popover must contain at least one child');
    }

    if (children.length > 2) {
      // eslint-disable-next-line no-console
      console.warn('Popover must contain at most two children');
    }
  }

  let popoverTrigger = undefined;
  let popoverSurface = undefined;

  if (children.length === 2) {
    popoverTrigger = children[0];
    popoverSurface = children[1];
  } else if (children.length === 1) {
    popoverSurface = children[0];
  }

  const [open, setOpenState] = useOpenState(initialState);
  const setOpenTimeoutRef = React.useRef(0);
  const setOpen = useEventCallback((e, shouldOpen) => {
    var _a;

    clearTimeout(setOpenTimeoutRef.current);

    if (!(e instanceof Event) && e.persist) {
      // < React 17 still uses pooled synthetic events
      e.persist();
    }

    if (e.type === 'mouseleave') {
      // FIXME leaking Node timeout type
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      setOpenTimeoutRef.current = setTimeout(() => {
        setOpenState(e, shouldOpen);
      }, (_a = props.mouseLeaveDelay) !== null && _a !== void 0 ? _a : 500);
    } else {
      setOpenState(e, shouldOpen);
    }
  }); // Clear timeout on unmount
  // Setting state after a component unmounts can cause memory leaks

  React.useEffect(() => {
    return () => {
      clearTimeout(setOpenTimeoutRef.current);
    };
  }, []);
  const toggleOpen = React.useCallback(e => {
    setOpen(e, !open);
  }, [setOpen, open]);
  const positioningRefs = usePopoverRefs(initialState);
  const {
    targetDocument
  } = useFluent();
  useOnClickOutside({
    contains: elementContains,
    element: targetDocument,
    callback: ev => setOpen(ev, false),
    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
    disabled: !open
  }); // only close on scroll for context, or when closeOnScroll is specified

  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: ev => setOpen(ev, false),
    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
    disabled: !open || !closeOnScroll
  });
  const {
    findFirstFocusable
  } = useFocusFinders();
  React.useEffect(() => {
    var _a;

    if (open && positioningRefs.contentRef.current) {
      const containerTabIndex = (_a = positioningRefs.contentRef.current.getAttribute('tabIndex')) !== null && _a !== void 0 ? _a : undefined;
      const firstFocusable = isNaN(containerTabIndex) ? findFirstFocusable(positioningRefs.contentRef.current) : positioningRefs.contentRef.current;
      firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
    }
  }, [findFirstFocusable, open, positioningRefs.contentRef]);
  return { ...initialState,
    ...positioningRefs,
    popoverTrigger,
    popoverSurface,
    open,
    setOpen,
    toggleOpen,
    setContextTarget,
    contextTarget,
    inline: (_a = props.inline) !== null && _a !== void 0 ? _a : false
  };
};
/**
 * Creates and manages the Popover open state
 */

function useOpenState(state) {
  const onOpenChange = useEventCallback((e, data) => {
    var _a;

    return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data);
  });
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  state.open = open !== undefined ? open : state.open;
  const setContextTarget = state.setContextTarget;
  const setOpen = React.useCallback((e, shouldOpen) => {
    if (shouldOpen && e.type === 'contextmenu') {
      setContextTarget(e);
    }

    if (!shouldOpen) {
      setContextTarget(undefined);
    }

    setOpenState(shouldOpen);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, {
      open: shouldOpen
    });
  }, [setOpenState, onOpenChange, setContextTarget]);
  return [open, setOpen];
}
/**
 * Creates and sets the necessary trigger, target and content refs used by Popover
 */


function usePopoverRefs(state) {
  const positioningOptions = {
    position: 'above',
    align: 'center',
    arrowPadding: 2 * popoverSurfaceBorderRadius,
    target: state.openOnContext ? state.contextTarget : undefined,
    ...resolvePositioningShorthand(state.positioning)
  }; // no reason to render arrow when covering the target

  if (positioningOptions.coverTarget) {
    state.withArrow = false;
  }

  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);
  }

  const {
    targetRef: triggerRef,
    containerRef: contentRef,
    arrowRef
  } = usePositioning(positioningOptions);
  return {
    triggerRef,
    contentRef,
    arrowRef
  };
}
//# sourceMappingURL=usePopover.js.map