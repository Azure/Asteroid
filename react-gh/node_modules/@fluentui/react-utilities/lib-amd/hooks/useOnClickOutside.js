define(["require", "exports", "react", "./useEventCallback"], function (require, exports, React, useEventCallback_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useOnClickOutside = void 0;
    /**
     * @internal
     * Utility to perform checks where a click/touch event was made outside a component
     */
    var useOnClickOutside = function (options) {
        var refs = options.refs, callback = options.callback, element = options.element, disabled = options.disabled, containsProp = options.contains;
        var timeoutId = React.useRef(undefined);
        useIFrameFocus(!disabled, element, callback);
        var listener = useEventCallback_1.useEventCallback(function (ev) {
            var contains = containsProp || (function (parent, child) { return !!(parent === null || parent === void 0 ? void 0 : parent.contains(child)); });
            var isOutside = refs.every(function (ref) { return !contains(ref.current || null, ev.target); });
            if (isOutside && !disabled) {
                callback(ev);
            }
        });
        React.useEffect(function () {
            // Store the current event to avoid triggering handlers immediately
            // Note this depends on a deprecated but extremely well supported quirk of the web platform
            // https://github.com/facebook/react/issues/20074
            var currentEvent = getWindowEvent(window);
            var conditionalHandler = function (event) {
                // Skip if this event is the same as the one running when we added the handlers
                if (event === currentEvent) {
                    currentEvent = undefined;
                    return;
                }
                listener(event);
            };
            if (!disabled) {
                // use capture phase because React can update DOM before the event bubbles to the document
                element === null || element === void 0 ? void 0 : element.addEventListener('click', conditionalHandler, true);
                element === null || element === void 0 ? void 0 : element.addEventListener('touchstart', conditionalHandler, true);
                element === null || element === void 0 ? void 0 : element.addEventListener('contextmenu', conditionalHandler, true);
            }
            // Garbage collect this event after it's no longer useful to avoid memory leaks
            timeoutId.current = window.setTimeout(function () {
                currentEvent = undefined;
            }, 1);
            return function () {
                element === null || element === void 0 ? void 0 : element.removeEventListener('click', conditionalHandler, true);
                element === null || element === void 0 ? void 0 : element.removeEventListener('touchstart', conditionalHandler, true);
                element === null || element === void 0 ? void 0 : element.removeEventListener('contextmenu', conditionalHandler, true);
                clearTimeout(timeoutId.current);
                currentEvent = undefined;
            };
        }, [listener, element, disabled]);
    };
    exports.useOnClickOutside = useOnClickOutside;
    var getWindowEvent = function (target) {
        var _a, _b, _c;
        if (target) {
            if (typeof target.window === 'object' && target.window === target) {
                // eslint-disable-next-line deprecation/deprecation
                return target.event;
            }
            // eslint-disable-next-line deprecation/deprecation
            return (_c = (_b = (_a = target.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.event) !== null && _c !== void 0 ? _c : undefined;
        }
        return undefined;
    };
    var FUI_FRAME_EVENT = 'fuiframefocus';
    /**
     * Since click events do not propagate past iframes, we use focus to detect if a
     * click has happened inside an iframe, since the only ways of focusing inside an
     * iframe are:
     *   - clicking inside
     *   - tabbing inside
     *
     * Polls the value of `document.activeElement`. If it is an iframe, then dispatch
     * a custom DOM event. When the custom event is received call the provided callback
     *
     * @param enableFrameFocusDispatch - boolean flag to start dispatching events
     * @param targetDocument - the document to dispatch events and set timeouts
     * @param pollDuration  - in milliseconds
     */
    var useIFrameFocus = function (enableFrameFocusDispatch, targetDocument, callback, pollDuration) {
        if (pollDuration === void 0) { pollDuration = 1000; }
        var timeoutRef = React.useRef();
        var listener = useEventCallback_1.useEventCallback(function (e) {
            if (callback) {
                callback(e);
            }
        });
        // Adds listener to the custom iframe focus event
        React.useEffect(function () {
            if (enableFrameFocusDispatch) {
                targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
            }
            return function () {
                targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
            };
        }, [targetDocument, enableFrameFocusDispatch, listener]);
        // Starts polling for the active element
        React.useEffect(function () {
            var _a;
            if (enableFrameFocusDispatch) {
                timeoutRef.current = (_a = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) === null || _a === void 0 ? void 0 : _a.setInterval(function () {
                    var activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
                    if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === 'IFRAME' || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === 'WEBVIEW') {
                        var event_1 = new CustomEvent(FUI_FRAME_EVENT, { bubbles: true });
                        activeElement.dispatchEvent(event_1);
                    }
                }, pollDuration);
            }
            return function () {
                var _a;
                (_a = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) === null || _a === void 0 ? void 0 : _a.clearTimeout(timeoutRef.current);
            };
        }, [targetDocument, enableFrameFocusDispatch, pollDuration]);
    };
});
//# sourceMappingURL=useOnClickOutside.js.map