{"version":3,"file":"mergeCallbacks.js","sourceRoot":"","sources":["../../../../../../../../packages/react-components/react-utilities/src/utils/mergeCallbacks.ts"],"names":[],"mappings":";;;;IAAA;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACH,SAAgB,cAAc,CAC5B,SAAgD,EAChD,SAAgD;QAEhD,OAAO;YAAC,cAAa;iBAAb,UAAa,EAAb,qBAAa,EAAb,IAAa;gBAAb,yBAAa;;YACnB,SAAS,aAAT,SAAS,uBAAT,SAAS,eAAM,IAAI,CAAC,CAAC;YACrB,SAAS,aAAT,SAAS,uBAAT,SAAS,eAAM,IAAI,CAAC,CAAC;QACvB,CAAC,CAAC;IACJ,CAAC;IARD,wCAQC","sourcesContent":["/**\n * @internal\n * Combine two event callbacks into a single callback function that calls each one in order.\n *\n * Usage example:\n * ```ts\n * state.slot.onChange = mergeCallbacks(state.slot.onChange, ev => {\n *   // Handle onChange\n * });\n * ```\n *\n * The primary use is to avoid the need to capture an existing callback (`state.slot.onChange` in the example) to a\n * local variable before replacing with a new listener that calls the existing one. This helps avoid bugs like:\n * * Infinite recursion by calling the re-assigned state.slot.onChange if it's not captured to a local variable.\n * * Missing a call to the original onChange due to an early return or other conditional.\n *\n * If you need a callback that is stable between renders, wrap the result in {@link useEventCallback}.\n *\n * @param callback1 - The first callback to be called, or undefined\n * @param callback2 - The second callback to be called, or undefined\n *\n * @returns A function that that calls the provided functions in order\n */\nexport function mergeCallbacks<Args extends unknown[]>(\n  callback1: ((...args: Args) => void) | undefined,\n  callback2: ((...args: Args) => void) | undefined,\n) {\n  return (...args: Args) => {\n    callback1?.(...args);\n    callback2?.(...args);\n  };\n}\n"]}