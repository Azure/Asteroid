import * as React from 'react';
import { useEventCallback } from './useEventCallback';
/**
 * @internal
 * Utility to perform checks where a click/touch event was made outside a component
 */

export const useOnClickOutside = options => {
  const {
    refs,
    callback,
    element,
    disabled,
    contains: containsProp
  } = options;
  const timeoutId = React.useRef(undefined);
  useIFrameFocus(!disabled, element, callback);
  const listener = useEventCallback(ev => {
    const contains = containsProp || ((parent, child) => !!(parent === null || parent === void 0 ? void 0 : parent.contains(child)));

    const isOutside = refs.every(ref => !contains(ref.current || null, ev.target));

    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  React.useEffect(() => {
    // Store the current event to avoid triggering handlers immediately
    // Note this depends on a deprecated but extremely well supported quirk of the web platform
    // https://github.com/facebook/react/issues/20074
    let currentEvent = getWindowEvent(window);

    const conditionalHandler = event => {
      // Skip if this event is the same as the one running when we added the handlers
      if (event === currentEvent) {
        currentEvent = undefined;
        return;
      }

      listener(event);
    };

    if (!disabled) {
      // use capture phase because React can update DOM before the event bubbles to the document
      element === null || element === void 0 ? void 0 : element.addEventListener('click', conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.addEventListener('touchstart', conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.addEventListener('contextmenu', conditionalHandler, true);
    } // Garbage collect this event after it's no longer useful to avoid memory leaks


    timeoutId.current = window.setTimeout(() => {
      currentEvent = undefined;
    }, 1);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener('click', conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener('touchstart', conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener('contextmenu', conditionalHandler, true);
      clearTimeout(timeoutId.current);
      currentEvent = undefined;
    };
  }, [listener, element, disabled]);
};

const getWindowEvent = target => {
  var _a, _b, _c;

  if (target) {
    if (typeof target.window === 'object' && target.window === target) {
      // eslint-disable-next-line deprecation/deprecation
      return target.event;
    } // eslint-disable-next-line deprecation/deprecation


    return (_c = (_b = (_a = target.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.event) !== null && _c !== void 0 ? _c : undefined;
  }

  return undefined;
};

const FUI_FRAME_EVENT = 'fuiframefocus';
/**
 * Since click events do not propagate past iframes, we use focus to detect if a
 * click has happened inside an iframe, since the only ways of focusing inside an
 * iframe are:
 *   - clicking inside
 *   - tabbing inside
 *
 * Polls the value of `document.activeElement`. If it is an iframe, then dispatch
 * a custom DOM event. When the custom event is received call the provided callback
 *
 * @param enableFrameFocusDispatch - boolean flag to start dispatching events
 * @param targetDocument - the document to dispatch events and set timeouts
 * @param pollDuration  - in milliseconds
 */

const useIFrameFocus = (enableFrameFocusDispatch, targetDocument, callback, pollDuration = 1000) => {
  const timeoutRef = React.useRef();
  const listener = useEventCallback(e => {
    if (callback) {
      callback(e);
    }
  }); // Adds listener to the custom iframe focus event

  React.useEffect(() => {
    if (enableFrameFocusDispatch) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
    }

    return () => {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
    };
  }, [targetDocument, enableFrameFocusDispatch, listener]); // Starts polling for the active element

  React.useEffect(() => {
    var _a;

    if (enableFrameFocusDispatch) {
      timeoutRef.current = (_a = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) === null || _a === void 0 ? void 0 : _a.setInterval(() => {
        const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;

        if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === 'IFRAME' || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === 'WEBVIEW') {
          const event = new CustomEvent(FUI_FRAME_EVENT, {
            bubbles: true
          });
          activeElement.dispatchEvent(event);
        }
      }, pollDuration);
    }

    return () => {
      var _a;

      (_a = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) === null || _a === void 0 ? void 0 : _a.clearTimeout(timeoutRef.current);
    };
  }, [targetDocument, enableFrameFocusDispatch, pollDuration]);
};
//# sourceMappingURL=useOnClickOutside.js.map