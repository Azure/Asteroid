import { DispatchWithoutAction } from 'react';
import * as React_2 from 'react';

/**
 * @internal
 * resolve the trigger props to the children, either by calling the render function, or cloning with the new props.
 */
export declare function applyTriggerPropsToChildren<TriggerChildProps>(children: TriggerProps<TriggerChildProps>['children'], triggerChildProps: TriggerChildProps): React_2.ReactElement | null;

/**
 * Helper type for inferring the type of the as prop from a Props type.
 *
 * For example:
 * ```
 * type Example<T> = T extends AsIntrinsicElement<infer As> ? As : never;
 * ```
 */
declare type AsIntrinsicElement<As extends keyof JSX.IntrinsicElements> = {
    as?: As;
};

/**
 * Verifies if an application can use DOM.
 */
export declare function canUseDOM(): boolean;

/**
 * @internal
 * Clamps `value` to a number between the min and max.
 *
 * @param value - the value to be clamped
 * @param min - the lowest valid value
 * @param max - the highest valid value
 */
export declare const clamp: (value: number, min: number, max: number) => number;

/**
 * Defines the Props type for a component given its slots and the definition of which one is the primary slot,
 * defaulting to root if one is not provided.
 */
export declare type ComponentProps<Slots extends SlotPropsRecord, Primary extends keyof Slots = 'root'> = Omit<Slots, Primary & 'root'> & PropsWithoutRef<ExtractSlotProps<Slots[Primary]>>;

/**
 * Defines the State object of a component given its slots.
 */
export declare type ComponentState<Slots extends SlotPropsRecord> = {
    components: {
        [Key in keyof Slots]-?: React_2.ComponentType<ExtractSlotProps<Slots[Key]>> | (ExtractSlotProps<Slots[Key]> extends AsIntrinsicElement<infer As> ? As : keyof JSX.IntrinsicElements);
    };
} & {
    [Key in keyof Slots]: ReplaceNullWithUndefined<Exclude<Slots[Key], SlotShorthandValue | (Key extends 'root' ? null : never)>>;
};

/**
 * HTML element types that are not allowed to have children.
 *
 * Reference: https://developer.mozilla.org/en-US/docs/Glossary/Empty_element
 */
declare type EmptyIntrisicElements = 'area' | 'base' | 'br' | 'col' | 'embed' | 'hr' | 'img' | 'input' | 'link' | 'meta' | 'param' | 'source' | 'track' | 'wbr';

/**
 * Removes SlotShorthandValue and null from the slot type, extracting just the slot's Props object.
 */
export declare type ExtractSlotProps<S> = Exclude<S, SlotShorthandValue | null | undefined>;

/**
 * @internal
 * Allows a component to be tagged as a FluentUI trigger component.
 *
 * Triggers are special-case components: they attach event listeners and other props on their child,
 * and use them to trigger another component to show. Examples include `MenuTrigger` and `Tooltip`.
 *
 * A component can be tagged as a trigger as follows:
 * ```ts
 * const MyComponent: React.FC<MyComponentProps> & FluentTriggerComponent = ...;
 *
 * MyComponent.isFluentTriggerComponent = true; // MUST also set this to true
 * ```
 */
export declare type FluentTriggerComponent = {
    isFluentTriggerComponent?: boolean;
};

/**
 * Return type for `React.forwardRef`, including inference of the proper typing for the ref.
 */
export declare type ForwardRefComponent<Props> = ObscureEventName extends keyof Props ? Required<Props>[ObscureEventName] extends React_2.PointerEventHandler<infer Element> ? React_2.ForwardRefExoticComponent<Props & React_2.RefAttributes<Element>> : never : never;

/**
 * Given an element tagname and user props, filters the props to only allowed props for the given
 * element type.
 * @param tagName - Tag name (e.g. "div")
 * @param props - Props object
 * @param excludedPropNames - List of props to disallow
 */
export declare function getNativeElementProps<TAttributes extends React_2.HTMLAttributes<any>>(tagName: string, props: {}, excludedPropNames?: string[]): TAttributes;

/**
 * Splits the native props into ones that go to the `root` slot, and ones that go to the primary slot.
 *
 * This function is only for use with components that have a primary slot other than `root`.
 * Most components should use {@link getNativeElementProps} for their root slot if it is the primary slot.
 *
 * @returns An object containing the native props for the `root` and primary slots.
 */
export declare const getPartitionedNativeProps: <Props extends Pick<React_2.HTMLAttributes<HTMLElement>, "style" | "className">, ExcludedPropKeys extends Extract<keyof Props, string> = never>({ primarySlotTagName, props, excludedPropNames, }: {
    /** The primary slot's element type (e.g. 'div') */
    primarySlotTagName: keyof JSX.IntrinsicElements;
    /** The component's props object */
    props: Props;
    /** List of native props to exclude from the returned value */
    excludedPropNames?: ExcludedPropKeys[] | undefined;
}) => {
    root: {
        style: React_2.CSSProperties | undefined;
        className: string | undefined;
    };
    primary: Omit<Props, ExcludedPropKeys>;
};

/**
 * @internal
 * Finds and swaps a provided key for it's right to left format.
 */
export declare const getRTLSafeKey: (key: string, dir: 'ltr' | 'rtl') => string;

/**
 * Given the state and an array of slot names, will break out `slots` and `slotProps`
 * collections.
 *
 * The root is derived from a mix of `components` props and `as` prop.
 *
 * Slots will render as null if they are rendered as primitives with undefined children.
 *
 * The slotProps will always omit the `as` prop within them, and for slots that are string
 * primitives, the props will be filtered according to the slot type by the type system.
 * For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable
 * anchor props. Note that this is only enforced at build time by Typescript -- there is no
 * runtime code filtering props in this function.
 *
 * @param state - State including slot definitions
 * @returns An object containing the `slots` map and `slotProps` map.
 */
export declare function getSlots<R extends SlotPropsRecord>(state: ComponentState<R>): {
    slots: Slots<R>;
    slotProps: ObjectSlotProps<R>;
};

/**
 * @internal
 * Gets the trigger element of a FluentTriggerComponent (such as Tooltip or MenuTrigger).
 *
 * In the case where the immediate child is itself a FluentTriggerComponent and/or React Fragment,
 * it returns the first descendant that is _not_ a FluentTriggerComponent or Fragment.
 * This allows multiple triggers to be stacked, and still apply their props to the actual trigger element.
 *
 * For example, the following returns `<div id="child" />`:
 * ```jsx
 * getTriggerChild(
 *   <Tooltip>
 *     <MenuTrigger>
 *       <div id="child" />
 *     </MenuTrigger>
 *   </Tooltip>
 * );
 * ```
 *
 * In the case where the immediate child is not a valid element,
 * null is returned
 */
export declare function getTriggerChild<TriggerChildProps>(children: TriggerProps<TriggerChildProps>['children']): (React_2.ReactElement<Partial<TriggerChildProps>> & {
    ref?: React_2.Ref<any>;
}) | null;

/**
 * Helper type for {@link Slot}. Modifies `JSX.IntrinsicElements[Type]`:
 * * Removes legacy string ref.
 * * Disallows children for empty tags like 'img'.
 */
declare type IntrisicElementProps<Type extends keyof JSX.IntrinsicElements> = React_2.PropsWithRef<JSX.IntrinsicElements[Type]> & (Type extends EmptyIntrisicElements ? {
    children?: never;
} : {});

/**
 * @internal
 * Checks if a given element is a FluentUI trigger (e.g. `MenuTrigger` or `Tooltip`).
 * See the {@link FluentTriggerComponent} type for more info.
 */
export declare function isFluentTrigger(element: React_2.ReactElement): element is React_2.ReactElement<TriggerProps>;

/**
 * @internal
 * Verifies if a given node is an HTMLElement,
 * this method works seamlessly with frames and elements from different documents
 *
 * This is required as simply using `instanceof`
 * might be problematic while operating with [multiple realms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms)
 *
 */
export declare function isHTMLElement(element?: Node | null | undefined): element is HTMLElement;

/**
 * @internal
 * Checks that the element has default behaviour from user input on click or 'Enter'/'Space' keys
 */
export declare function isInteractiveHTMLElement(element: Node | null | undefined): boolean;

/**
 * Guard method that validates if a shorthand is a slot
 * can be used to extends properties provided by a slot
 *
 * @example
 * ```
 * const backdropSlot = resolveShorthand(backdrop, {
 *  defaultProps: {
 *    onClick: useEventCallback(event => {
 *     if (isResolvedShorthand(backdrop)) {
 *        backdrop.onClick?.(event)
 *      }
 *      // do something after passing click down the line
 *    }),
 *  },
 * })
 * ```
 * @example
 * ```
 * const handleBackDropClick = (event) => {
 *  // do your thing
 * }
 * const backdropSlot = resolveShorthand(backdrop, {
 *  defaultProps: {
 *    onClick: useEventCallback(
 *      mergeCallbacks(isResolvedShorthand(backdrop) ? backdrop.onClick : undefined, handleBackdropClick)
 *    )
 * })
 * ```
 */
export declare function isResolvedShorthand<Shorthand extends Slot<UnknownSlotProps>>(shorthand?: Shorthand): shorthand is ExtractSlotProps<Shorthand>;

/**
 * Evaluates to true if the given type contains exactly one string, or false if it is a union of strings.
 *
 * ```
 * IsSingleton<'a'> // true
 * IsSingleton<'a' | 'b' | 'c'> // false
 * ```
 */
declare type IsSingleton<T extends string> = {
    [K in T]: Exclude<T, K> extends never ? true : false;
}[T];

/**
 * @internal
 * Combine two event callbacks into a single callback function that calls each one in order.
 *
 * Usage example:
 * ```ts
 * state.slot.onChange = mergeCallbacks(state.slot.onChange, ev => {
 *   // Handle onChange
 * });
 * ```
 *
 * The primary use is to avoid the need to capture an existing callback (`state.slot.onChange` in the example) to a
 * local variable before replacing with a new listener that calls the existing one. This helps avoid bugs like:
 * * Infinite recursion by calling the re-assigned state.slot.onChange if it's not captured to a local variable.
 * * Missing a call to the original onChange due to an early return or other conditional.
 *
 * If you need a callback that is stable between renders, wrap the result in {@link useEventCallback}.
 *
 * @param callback1 - The first callback to be called, or undefined
 * @param callback2 - The second callback to be called, or undefined
 *
 * @returns A function that that calls the provided functions in order
 */
export declare function mergeCallbacks<Args extends unknown[]>(callback1: ((...args: Args) => void) | undefined, callback2: ((...args: Args) => void) | undefined): (...args: Args) => void;

declare type ObjectSlotProps<S extends SlotPropsRecord> = {
    [K in keyof S]-?: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As> ? UnionToIntersection<JSX.IntrinsicElements[As]> : ExtractSlotProps<S[K]> extends React_2.ComponentType<infer P> ? P : never;
};

/**
 * This is part of a hack to infer the element type from a native element *props* type.
 * The only place the original element is found in a native props type (at least that's workable
 * for inference) is in the event handlers, so some of the helper types use this event handler
 * name to infer the original element type.
 *
 * Notes:
 * - Using an extremely obscure event handler reduces the likelihood that its signature will be
 *   modified in any component's props.
 * - Inferring based on a single prop name instead of a larger type like `DOMAttributes<T>` should be
 *   less expensive for typescript to evaluate and is less likely to result in type expansion in .d.ts.
 */
declare type ObscureEventName = 'onLostPointerCaptureCapture';

/**
 * Removes the 'ref' prop from the given Props type, leaving unions intact (such as the discriminated union created by
 * IntrinsicSlotProps). This allows IntrinsicSlotProps to be used with React.forwardRef.
 *
 * The conditional "extends unknown" (always true) exploits a quirk in the way TypeScript handles conditional
 * types, to prevent unions from being expanded.
 */
declare type PropsWithoutRef<P> = 'ref' extends keyof P ? (P extends unknown ? Omit<P, 'ref'> : P) : P;

/**
 * A Ref function which can be treated like a ref object in that it has an attached
 * current property, which will be updated as the ref is evaluated.
 */
export declare type RefObjectFunction<T> = React_2.RefObject<T> & ((value: T) => void);

/**
 * If type T includes `null`, remove it and add `undefined` instead.
 */
declare type ReplaceNullWithUndefined<T> = T extends null ? Exclude<T, null> | undefined : T;

/**
 * Resets generated IDs, should be used only in tests.
 */
export declare function resetIdsForTests(): void;

/**
 * Resolves shorthands into slot props, to ensure normalization of the signature
 * being passed down to getSlots method
 * @param value - the base shorthand props
 * @param options - options to resolve shorthand props
 */
export declare const resolveShorthand: ResolveShorthandFunction;

export declare type ResolveShorthandFunction<Props extends UnknownSlotProps = UnknownSlotProps> = {
    <P extends Props | null>(value: P | SlotShorthandValue | undefined, options?: ResolveShorthandOptions<P, true>): ReplaceNullWithUndefined<P>;
    <P extends Props | null>(value: P | SlotShorthandValue | undefined, options?: ResolveShorthandOptions<P, boolean>): ReplaceNullWithUndefined<P> | undefined;
};

export declare type ResolveShorthandOptions<Props, Required extends boolean = false> = {
    required?: Required;
    defaultProps?: Props;
};

/**
 * The props type and shorthand value for a slot. Type is either a single intrinsic element like `'div'`,
 * or a component like `typeof Button`.
 *
 * If a slot needs to support multiple intrinsic element types, use the `AlternateAs` param (see examples below).
 *
 * By default, slots can be set to `null` to prevent them from being rendered. If a slot must always be rendered,
 * wrap with `NonNullable` (see examples below).
 *
 * @example
 * ```
 * // Intrinsic element examples:
 * Slot<'div'> // Slot is always div
 * Slot<'button', 'a'> // Defaults to button, but allows as="a" with anchor-specific props
 * Slot<'span', 'div' | 'pre'> // Defaults to span, but allows as="div" or as="pre"
 * NonNullable<Slot<'div'>> // Slot that will always be rendered (can't be set to null by the user)
 *
 * // Component examples:
 * Slot<typeof Button> // Slot is always a Button, and accepts all of Button's Props
 * NonNullable<Slot<typeof Label>> // Slot is a Label and will always be rendered (can't be set to null by the user)
 * ```
 */
export declare type Slot<Type extends keyof JSX.IntrinsicElements | React_2.ComponentType | React_2.VoidFunctionComponent | UnknownSlotProps, AlternateAs extends keyof JSX.IntrinsicElements = never> = IsSingleton<Extract<Type, string>> extends true ? WithSlotShorthandValue<Type extends keyof JSX.IntrinsicElements ? {
    as?: Type;
} & WithSlotRenderFunction<IntrisicElementProps<Type>> : Type extends React_2.ComponentType<infer Props> ? WithSlotRenderFunction<Props> : Type> | {
    [As in AlternateAs]: {
        as: As;
    } & WithSlotRenderFunction<IntrisicElementProps<As>>;
}[AlternateAs] | null : 'Error: First parameter to Slot must not be not a union of types. See documentation of Slot type.';

/**
 * Helper type to correctly define the slot class names object.
 */
export declare type SlotClassNames<Slots> = {
    [SlotName in keyof Slots]-?: string;
};

/**
 * Matches any component's Slots type (such as ButtonSlots).
 *
 * This should ONLY be used in type templates as in `extends SlotPropsRecord`;
 * it shouldn't be used as a component's Slots type.
 */
export declare type SlotPropsRecord = Record<string, UnknownSlotProps | SlotShorthandValue | null | undefined>;

export declare type SlotRenderFunction<Props> = (Component: React_2.ElementType<Props>, props: Omit<Props, 'children' | 'as'>) => React_2.ReactNode;

export declare type Slots<S extends SlotPropsRecord> = {
    [K in keyof S]: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As> ? As : ExtractSlotProps<S[K]> extends React_2.ComponentType<infer P> ? React_2.ElementType<NonNullable<P>> : React_2.ElementType<ExtractSlotProps<S[K]>>;
};

/**
 * The shorthand value of a slot allows specifying its child
 */
export declare type SlotShorthandValue = React_2.ReactChild | React_2.ReactNode[] | React_2.ReactPortal;

/**
 * When using SSR with Fluent UI, applications must be wrapped in an SSRProvider. This ensures that auto generated ids
 * are consistent between the client and server.
 *
 * @public
 */
export declare const SSRProvider: React_2.FC;

/**
 * A trigger may have a children that could be either:
 * 1. A single element
 * 2. A render function that will receive properties and must return a valid element or null
 * 3. null or undefined
 */
export declare type TriggerProps<TriggerChildProps = unknown> = {
    children?: React_2.ReactElement | ((props: TriggerChildProps) => React_2.ReactElement | null) | null;
};

/**
 * Converts a union type (`A | B | C`) to an intersection type (`A & B & C`)
 */
declare type UnionToIntersection<U> = (U extends unknown ? (x: U) => U : never) extends (x: infer I) => U ? I : never;

/**
 * Matches any slot props type.
 *
 * This should ONLY be used in type templates as in `extends UnknownSlotProps`;
 * it shouldn't be used as the type of a slot.
 */
declare type UnknownSlotProps = Pick<React_2.HTMLAttributes<HTMLElement>, 'children' | 'className' | 'style'> & {
    as?: keyof JSX.IntrinsicElements;
};

/**
 * @internal
 *
 * A `useState`-like hook to manage a value that could be either controlled or uncontrolled,
 * such as a checked state or text input string.
 *
 * Unlike `setState`, it's okay to call the returned updater (dispatch) function for either a
 * controlled or uncontrolled component. Calls will only be respected if the component is uncontrolled.
 *
 * @returns Same as [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate): an array
 * of the current value and an updater (dispatch) function. The updater function is referentially
 * stable (won't change during the component's lifecycle). It can take either a new value, or a
 * function which is passed the previous value and returns the new value. Unlike `setState`, calls
 * to the updater function will only be respected if the component is uncontrolled.
 * @see https://reactjs.org/docs/uncontrolled-components.html
 */
export declare const useControllableState: <State>(options: UseControllableStateOptions<State>) => [State, React_2.Dispatch<React_2.SetStateAction<State>>];

/**
 * @internal
 */
export declare type UseControllableStateOptions<State> = {
    /**
     * User-provided default state or initializer, for uncontrolled usage.
     */
    defaultState?: State | (() => State);
    /**
     * User-provided controlled state. `undefined` means internal state will be used.
     */
    state: State | undefined;
    /**
     * Used as the initial state if `state` and `defaultState` are both `undefined`.
     * If `undefined` is the correct initial state, pass that here.
     */
    initialState: State;
};

/**
 * @internal
 * https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback
 *
 * Modified `useCallback` that can be used when dependencies change too frequently. Can occur when
 * e.g. user props are dependencies which could change on every render
 * e.g. volatile values (i.e. useState/useDispatch) are dependencies which could change frequently
 *
 * This should not be used often, but can be a useful re-render optimization since the callback is a ref and
 * will not be invalidated between re-renders
 *
 * @param fn - The callback function that will be used
 */
export declare const useEventCallback: <Args extends unknown[], Return>(fn: (...args: Args) => Return) => (...args: Args) => Return;

/**
 * @internal
 * Checks if components was mounted the first time.
 * Since concurrent mode will be released in the future this needs to be verified
 * Currently (React 17) will always render the initial mount once
 * https://codesandbox.io/s/heuristic-brook-s4w0q?file=/src/App.jsx
 * https://codesandbox.io/s/holy-grass-8nieu?file=/src/App.jsx
 *
 * @example
 * const isFirstMount = useFirstMount();
 */
export declare function useFirstMount(): boolean;

/**
 * @internal
 * Forces a re-render, similar to `forceUpdate` in class components.
 */
export declare function useForceUpdate(): DispatchWithoutAction;

/**
 * Hook to generate a unique ID.
 *
 * @param prefix - Optional prefix for the ID. Defaults to 'fui-'.
 * @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,
 *  without conditioning the hook call
 * @returns The ID
 */
export declare function useId(prefix?: string, providedId?: string): string;

/**
 * React currently throws a warning when using useLayoutEffect on the server. To get around it, we can conditionally
 * useEffect on the server (no-op) and useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also need affected components to render on
 * the server.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 */
export declare const useIsomorphicLayoutEffect: typeof React_2.useEffect;

/**
 * Returns whether the component is currently being server side rendered or hydrated on the client. Can be used to delay
 * browser-specific rendering until after hydration. May cause re-renders on a client when is used within SSRProvider.
 */
export declare function useIsSSR(): boolean;

/**
 * React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that
 * updates all provided refs
 * @param refs - Refs to collectively update with one ref value.
 * @returns A function with an attached "current" prop, so that it can be treated like a RefObject.
 */
export declare function useMergedRefs<T>(...refs: (React_2.Ref<T> | undefined)[]): RefObjectFunction<T>;

/**
 * @internal
 */
export declare type UseOnClickOrScrollOutsideOptions = {
    /**
     * The element to listen for the click event
     */
    element: Document | undefined;
    /**
     * Refs to elements that check if the click is outside
     */
    refs: React_2.MutableRefObject<HTMLElement | undefined | null>[];
    /**
     * By default uses element.contains, but custom contain function can be provided
     * @param parentRef - provided parent ref
     * @param child - event target element
     */
    contains?(parent: HTMLElement | null, child: HTMLElement): boolean;
    /**
     * Disables event listeners
     */
    disabled?: boolean;
    /**
     * Called if the click is outside the element refs
     */
    callback: (ev: MouseEvent | TouchEvent) => void;
};

/**
 * @internal
 * Utility to perform checks where a click/touch event was made outside a component
 */
export declare const useOnClickOutside: (options: UseOnClickOrScrollOutsideOptions) => void;

/**
 * @internal
 * Utility to perform checks where a click/touch event was made outside a component
 */
export declare const useOnScrollOutside: (options: UseOnClickOrScrollOutsideOptions) => void;

/**
 * @internal
 */
export declare const usePrevious: <ValueType = unknown>(value: ValueType) => ValueType | null;

/**
 * @internal
 * Helper to manage a browser timeout.
 * Ensures that the timeout isn't set multiple times at once,
 * and is cleaned up when the component is unloaded.
 *
 * @returns A pair of [setTimeout, clearTimeout] that are stable between renders.
 */
export declare function useTimeout(): readonly [(fn: () => void, delay: number) => void, () => void];

/**
 * Helper type for {@link Slot}. Takes the props we want to support for a slot and adds the ability for `children`
 * to be a render function that takes those props.
 */
declare type WithSlotRenderFunction<Props extends {
    children?: unknown;
}> = Props & {
    children?: Props['children'] | SlotRenderFunction<Props>;
};

/**
 * Helper type for {@link Slot}. Adds shorthand types that are assignable to the slot's `children`.
 */
declare type WithSlotShorthandValue<Props extends {
    children?: unknown;
}> = Props | Extract<SlotShorthandValue, Props['children']>;

export { }
