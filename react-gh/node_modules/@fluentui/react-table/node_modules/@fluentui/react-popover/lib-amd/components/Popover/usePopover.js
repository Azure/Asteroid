define(["require", "exports", "tslib", "react", "@fluentui/react-utilities", "@fluentui/react-shared-contexts", "@fluentui/react-positioning", "@fluentui/react-portal", "@fluentui/react-tabster", "../PopoverSurface/index", "./constants"], function (require, exports, tslib_1, React, react_utilities_1, react_shared_contexts_1, react_positioning_1, react_portal_1, react_tabster_1, index_1, constants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.usePopover_unstable = void 0;
    /**
     * Create the state required to render Popover.
     *
     * The returned state can be modified with hooks such as usePopoverStyles,
     * before being passed to renderPopover_unstable.
     *
     * @param props - props from this instance of Popover
     */
    var usePopover_unstable = function (props) {
        var _a;
        var _b = react_positioning_1.usePositioningMouseTarget(), contextTarget = _b[0], setContextTarget = _b[1];
        var initialState = tslib_1.__assign({ size: 'medium', contextTarget: contextTarget, setContextTarget: setContextTarget }, props);
        var children = React.Children.toArray(props.children);
        if (process.env.NODE_ENV !== 'production') {
            if (children.length === 0) {
                // eslint-disable-next-line no-console
                console.warn('Popover must contain at least one child');
            }
            if (children.length > 2) {
                // eslint-disable-next-line no-console
                console.warn('Popover must contain at most two children');
            }
        }
        var popoverTrigger = undefined;
        var popoverSurface = undefined;
        if (children.length === 2) {
            popoverTrigger = children[0];
            popoverSurface = children[1];
        }
        else if (children.length === 1) {
            popoverSurface = children[0];
        }
        var _c = useOpenState(initialState), open = _c[0], setOpenState = _c[1];
        var setOpenTimeoutRef = React.useRef(0);
        var setOpen = react_utilities_1.useEventCallback(function (e, shouldOpen) {
            var _a;
            clearTimeout(setOpenTimeoutRef.current);
            if (!(e instanceof Event) && e.persist) {
                // < React 17 still uses pooled synthetic events
                e.persist();
            }
            if (e.type === 'mouseleave') {
                // FIXME leaking Node timeout type
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                setOpenTimeoutRef.current = setTimeout(function () {
                    setOpenState(e, shouldOpen);
                }, (_a = props.mouseLeaveDelay) !== null && _a !== void 0 ? _a : 500);
            }
            else {
                setOpenState(e, shouldOpen);
            }
        });
        // Clear timeout on unmount
        // Setting state after a component unmounts can cause memory leaks
        React.useEffect(function () {
            return function () {
                clearTimeout(setOpenTimeoutRef.current);
            };
        }, []);
        var toggleOpen = React.useCallback(function (e) {
            setOpen(e, !open);
        }, [setOpen, open]);
        var positioningRefs = usePopoverRefs(initialState);
        var targetDocument = react_shared_contexts_1.useFluent_unstable().targetDocument;
        react_utilities_1.useOnClickOutside({
            contains: react_portal_1.elementContains,
            element: targetDocument,
            callback: function (ev) { return setOpen(ev, false); },
            refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
            disabled: !open,
        });
        // only close on scroll for context, or when closeOnScroll is specified
        var closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
        react_utilities_1.useOnScrollOutside({
            contains: react_portal_1.elementContains,
            element: targetDocument,
            callback: function (ev) { return setOpen(ev, false); },
            refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
            disabled: !open || !closeOnScroll,
        });
        var findFirstFocusable = react_tabster_1.useFocusFinders().findFirstFocusable;
        React.useEffect(function () {
            var _a;
            if (open && positioningRefs.contentRef.current) {
                var containerTabIndex = (_a = positioningRefs.contentRef.current.getAttribute('tabIndex')) !== null && _a !== void 0 ? _a : undefined;
                var firstFocusable = isNaN(containerTabIndex)
                    ? findFirstFocusable(positioningRefs.contentRef.current)
                    : positioningRefs.contentRef.current;
                firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
            }
        }, [findFirstFocusable, open, positioningRefs.contentRef]);
        return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, initialState), positioningRefs), { popoverTrigger: popoverTrigger, popoverSurface: popoverSurface, open: open, setOpen: setOpen, toggleOpen: toggleOpen, setContextTarget: setContextTarget, contextTarget: contextTarget, inline: (_a = props.inline) !== null && _a !== void 0 ? _a : false });
    };
    exports.usePopover_unstable = usePopover_unstable;
    /**
     * Creates and manages the Popover open state
     */
    function useOpenState(state) {
        var onOpenChange = react_utilities_1.useEventCallback(function (e, data) { var _a; return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data); });
        var _a = react_utilities_1.useControllableState({
            state: state.open,
            defaultState: state.defaultOpen,
            initialState: false,
        }), open = _a[0], setOpenState = _a[1];
        state.open = open !== undefined ? open : state.open;
        var setContextTarget = state.setContextTarget;
        var setOpen = React.useCallback(function (e, shouldOpen) {
            if (shouldOpen && e.type === 'contextmenu') {
                setContextTarget(e);
            }
            if (!shouldOpen) {
                setContextTarget(undefined);
            }
            setOpenState(shouldOpen);
            onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, { open: shouldOpen });
        }, [setOpenState, onOpenChange, setContextTarget]);
        return [open, setOpen];
    }
    /**
     * Creates and sets the necessary trigger, target and content refs used by Popover
     */
    function usePopoverRefs(state) {
        var positioningOptions = tslib_1.__assign({ position: 'above', align: 'center', arrowPadding: 2 * constants_1.popoverSurfaceBorderRadius, target: state.openOnContext ? state.contextTarget : undefined }, react_positioning_1.resolvePositioningShorthand(state.positioning));
        // no reason to render arrow when covering the target
        if (positioningOptions.coverTarget) {
            state.withArrow = false;
        }
        if (state.withArrow) {
            positioningOptions.offset = react_positioning_1.mergeArrowOffset(positioningOptions.offset, index_1.arrowHeights[state.size]);
        }
        var _a = react_positioning_1.usePositioning(positioningOptions), triggerRef = _a.targetRef, contentRef = _a.containerRef, arrowRef = _a.arrowRef;
        return {
            triggerRef: triggerRef,
            contentRef: contentRef,
            arrowRef: arrowRef,
        };
    }
});
//# sourceMappingURL=usePopover.js.map