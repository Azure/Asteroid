define(["require", "exports", "tslib", "@griffel/react", "@fluentui/react-tabster", "@fluentui/react-theme"], function (require, exports, tslib_1, react_1, react_tabster_1, react_theme_1) {
    "use strict";
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCheckboxStyles_unstable = exports.checkboxClassNames = void 0;
    exports.checkboxClassNames = {
        root: 'fui-Checkbox',
        label: 'fui-Checkbox__label',
        input: 'fui-Checkbox__input',
        indicator: 'fui-Checkbox__indicator',
    };
    // The indicator size is used by the indicator and label styles
    var indicatorSizeMedium = '16px';
    var indicatorSizeLarge = '20px';
    var useRootBaseClassName = react_1.makeResetStyles(tslib_1.__assign({ position: 'relative', display: 'inline-flex' }, react_tabster_1.createFocusOutlineStyle({ style: {}, selector: 'focus-within' })));
    var useInputBaseClassName = react_1.makeResetStyles((_a = {
            boxSizing: 'border-box',
            cursor: 'pointer',
            height: '100%',
            margin: 0,
            opacity: 0,
            position: 'absolute',
            top: 0,
            // Calculate the width of the hidden input by taking into account the size of the indicator + the padding around it.
            // This is done so that clicking on that "empty space" still toggles the checkbox.
            width: "calc(" + indicatorSizeMedium + " + 2 * " + react_theme_1.tokens.spacingHorizontalS + ")"
        },
        // When unchecked, hide the the checkmark icon (child of the indicator slot)
        _a[":not(:checked):not(:indeterminate) ~ ." + exports.checkboxClassNames.indicator + " > *"] = {
            opacity: 0,
        },
        // Colors for the unchecked state
        _a[':enabled:not(:checked):not(:indeterminate)'] = (_b = {},
            _b["& ~ ." + exports.checkboxClassNames.label] = {
                color: react_theme_1.tokens.colorNeutralForeground3,
            },
            _b["& ~ ." + exports.checkboxClassNames.indicator] = {
                borderColor: react_theme_1.tokens.colorNeutralStrokeAccessible,
            },
            _b[':hover'] = (_c = {},
                _c["& ~ ." + exports.checkboxClassNames.label] = {
                    color: react_theme_1.tokens.colorNeutralForeground2,
                },
                _c["& ~ ." + exports.checkboxClassNames.indicator] = {
                    borderColor: react_theme_1.tokens.colorNeutralStrokeAccessibleHover,
                },
                _c),
            _b[':active:hover'] = (_d = {},
                _d["& ~ ." + exports.checkboxClassNames.label] = {
                    color: react_theme_1.tokens.colorNeutralForeground1,
                },
                _d["& ~ ." + exports.checkboxClassNames.indicator] = {
                    borderColor: react_theme_1.tokens.colorNeutralStrokeAccessiblePressed,
                },
                _d),
            _b),
        // Colors for the checked state
        _a[':enabled:checked:not(:indeterminate)'] = (_e = {},
            _e["& ~ ." + exports.checkboxClassNames.label] = {
                color: react_theme_1.tokens.colorNeutralForeground1,
            },
            _e["& ~ ." + exports.checkboxClassNames.indicator] = {
                backgroundColor: react_theme_1.tokens.colorCompoundBrandBackground,
                color: react_theme_1.tokens.colorNeutralForegroundInverted,
                borderColor: react_theme_1.tokens.colorCompoundBrandBackground,
            },
            _e[':hover'] = (_f = {},
                _f["& ~ ." + exports.checkboxClassNames.indicator] = {
                    backgroundColor: react_theme_1.tokens.colorCompoundBrandBackgroundHover,
                    borderColor: react_theme_1.tokens.colorCompoundBrandBackgroundHover,
                },
                _f),
            _e[':active:hover'] = (_g = {},
                _g["& ~ ." + exports.checkboxClassNames.indicator] = {
                    backgroundColor: react_theme_1.tokens.colorCompoundBrandBackgroundPressed,
                    borderColor: react_theme_1.tokens.colorCompoundBrandBackgroundPressed,
                },
                _g),
            _e),
        // Colors for the mixed state
        _a[':enabled:indeterminate'] = (_h = {},
            _h["& ~ ." + exports.checkboxClassNames.label] = {
                color: react_theme_1.tokens.colorNeutralForeground1,
            },
            _h["& ~ ." + exports.checkboxClassNames.indicator] = {
                borderColor: react_theme_1.tokens.colorCompoundBrandStroke,
                color: react_theme_1.tokens.colorCompoundBrandForeground1,
            },
            _h[':hover'] = (_j = {},
                _j["& ~ ." + exports.checkboxClassNames.indicator] = {
                    borderColor: react_theme_1.tokens.colorCompoundBrandStrokeHover,
                    color: react_theme_1.tokens.colorCompoundBrandForeground1Hover,
                },
                _j),
            _h[':active:hover'] = (_k = {},
                _k["& ~ ." + exports.checkboxClassNames.indicator] = {
                    borderColor: react_theme_1.tokens.colorCompoundBrandStrokePressed,
                    color: react_theme_1.tokens.colorCompoundBrandForeground1Pressed,
                },
                _k),
            _h),
        _a[':disabled'] = (_l = {
                cursor: 'default'
            },
            _l["& ~ ." + exports.checkboxClassNames.label] = {
                cursor: 'default',
                color: react_theme_1.tokens.colorNeutralForegroundDisabled,
                '@media (forced-colors: active)': {
                    color: 'GrayText',
                },
            },
            _l["& ~ ." + exports.checkboxClassNames.indicator] = {
                borderColor: react_theme_1.tokens.colorNeutralStrokeDisabled,
                color: react_theme_1.tokens.colorNeutralForegroundDisabled,
                '@media (forced-colors: active)': {
                    color: 'GrayText',
                },
            },
            _l["& ~ ." + exports.checkboxClassNames.indicator + " svg"] = {
                '@media (forced-colors: active)': {
                    color: 'GrayText',
                },
            },
            _l),
        _a));
    var useInputStyles = react_1.makeStyles({
        before: {
            right: 0,
        },
        after: {
            left: 0,
        },
        large: {
            width: "calc(" + indicatorSizeLarge + " + 2 * " + react_theme_1.tokens.spacingHorizontalS + ")",
        },
    });
    var useIndicatorBaseClassName = react_1.makeResetStyles({
        alignSelf: 'flex-start',
        boxSizing: 'border-box',
        flexShrink: 0,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        overflow: 'hidden',
        border: react_theme_1.tokens.strokeWidthThin + ' solid',
        borderRadius: react_theme_1.tokens.borderRadiusSmall,
        margin: react_theme_1.tokens.spacingVerticalS + ' ' + react_theme_1.tokens.spacingHorizontalS,
        fill: 'currentColor',
        pointerEvents: 'none',
        fontSize: '12px',
        height: indicatorSizeMedium,
        width: indicatorSizeMedium,
    });
    var useIndicatorStyles = react_1.makeStyles({
        large: {
            fontSize: '16px',
            height: indicatorSizeLarge,
            width: indicatorSizeLarge,
        },
        circular: tslib_1.__assign({}, react_1.shorthands.borderRadius(react_theme_1.tokens.borderRadiusCircular)),
    });
    // Can't use makeResetStyles here because Label is a component that may itself use makeResetStyles.
    var useLabelStyles = react_1.makeStyles({
        base: tslib_1.__assign({ alignSelf: 'center', cursor: 'pointer' }, react_1.shorthands.padding(react_theme_1.tokens.spacingVerticalS, react_theme_1.tokens.spacingHorizontalS)),
        before: {
            paddingRight: react_theme_1.tokens.spacingHorizontalXS,
        },
        after: {
            paddingLeft: react_theme_1.tokens.spacingHorizontalXS,
        },
        // Use a (negative) margin to account for the difference between the indicator's height and the label's line height.
        // This prevents the label from expanding the height of the checkbox, but preserves line height if the label wraps.
        medium: {
            marginTop: "calc((" + indicatorSizeMedium + " - " + react_theme_1.tokens.lineHeightBase300 + ") / 2)",
            marginBottom: "calc((" + indicatorSizeMedium + " - " + react_theme_1.tokens.lineHeightBase300 + ") / 2)",
        },
        large: {
            marginTop: "calc((" + indicatorSizeLarge + " - " + react_theme_1.tokens.lineHeightBase300 + ") / 2)",
            marginBottom: "calc((" + indicatorSizeLarge + " - " + react_theme_1.tokens.lineHeightBase300 + ") / 2)",
        },
    });
    /**
     * Apply styling to the Checkbox slots based on the state
     */
    var useCheckboxStyles_unstable = function (state) {
        var labelPosition = state.labelPosition, shape = state.shape, size = state.size;
        var rootBaseClassName = useRootBaseClassName();
        state.root.className = react_1.mergeClasses(exports.checkboxClassNames.root, rootBaseClassName, state.root.className);
        var inputBaseClassName = useInputBaseClassName();
        var inputStyles = useInputStyles();
        state.input.className = react_1.mergeClasses(exports.checkboxClassNames.input, inputBaseClassName, size === 'large' && inputStyles.large, inputStyles[labelPosition], state.input.className);
        var indicatorBaseClassName = useIndicatorBaseClassName();
        var indicatorStyles = useIndicatorStyles();
        if (state.indicator) {
            state.indicator.className = react_1.mergeClasses(exports.checkboxClassNames.indicator, indicatorBaseClassName, size === 'large' && indicatorStyles.large, shape === 'circular' && indicatorStyles.circular, state.indicator.className);
        }
        var labelStyles = useLabelStyles();
        if (state.label) {
            state.label.className = react_1.mergeClasses(exports.checkboxClassNames.label, labelStyles.base, labelStyles[size], labelStyles[labelPosition], state.label.className);
        }
        return state;
    };
    exports.useCheckboxStyles_unstable = useCheckboxStyles_unstable;
});
//# sourceMappingURL=useCheckboxStyles.js.map