"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCheckbox_unstable = void 0;

const React = /*#__PURE__*/require("react");

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_icons_1 = /*#__PURE__*/require("@fluentui/react-icons");

const react_label_1 = /*#__PURE__*/require("@fluentui/react-label");

const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");
/**
 * Create the state required to render Checkbox.
 *
 * The returned state can be modified with hooks such as useCheckboxStyles_unstable,
 * before being passed to renderCheckbox_unstable.
 *
 * @param props - props from this instance of Checkbox
 * @param ref - reference to `<input>` element of Checkbox
 */


const useCheckbox_unstable = (props, ref) => {
  const {
    disabled,
    required,
    shape = 'square',
    size = 'medium',
    labelPosition = 'after',
    onChange
  } = props;
  const [checked, setChecked] = react_utilities_1.useControllableState({
    defaultState: props.defaultChecked,
    state: props.checked,
    initialState: false
  });
  const nativeProps = react_utilities_1.getPartitionedNativeProps({
    props,
    primarySlotTagName: 'input',
    excludedPropNames: ['checked', 'defaultChecked', 'size', 'onChange']
  });
  const mixed = checked === 'mixed';
  const id = react_utilities_1.useId('checkbox-', nativeProps.primary.id);
  let checkmarkIcon;

  if (mixed) {
    if (shape === 'circular') {
      checkmarkIcon = React.createElement(react_icons_1.CircleFilled, null);
    } else {
      checkmarkIcon = size === 'large' ? React.createElement(react_icons_1.Square16Filled, null) : React.createElement(react_icons_1.Square12Filled, null);
    }
  } else {
    checkmarkIcon = size === 'large' ? React.createElement(react_icons_1.Checkmark16Filled, null) : React.createElement(react_icons_1.Checkmark12Filled, null);
  }

  const state = {
    shape,
    checked,
    size,
    labelPosition,
    components: {
      root: 'span',
      input: 'input',
      indicator: 'div',
      label: react_label_1.Label
    },
    root: react_utilities_1.resolveShorthand(props.root, {
      required: true,
      defaultProps: {
        ref: react_tabster_1.useFocusWithin(),
        ...nativeProps.root
      }
    }),
    input: react_utilities_1.resolveShorthand(props.input, {
      required: true,
      defaultProps: {
        type: 'checkbox',
        id,
        ref,
        checked: checked === true,
        ...nativeProps.primary
      }
    }),
    label: react_utilities_1.resolveShorthand(props.label, {
      required: false,
      defaultProps: {
        htmlFor: id,
        disabled,
        required,
        size: 'medium' // Even if the checkbox itself is large

      }
    }),
    indicator: react_utilities_1.resolveShorthand(props.indicator, {
      required: true,
      defaultProps: {
        'aria-hidden': true,
        children: checkmarkIcon
      }
    })
  };
  state.input.onChange = react_utilities_1.useEventCallback(ev => {
    const val = ev.currentTarget.indeterminate ? 'mixed' : ev.currentTarget.checked;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: val
    });
    setChecked(val);
  }); // Create a ref object for the input element so we can use it to set the indeterminate prop.
  // Use useMergedRefs, since the ref might be undefined or a function-ref (no .current)

  const inputRef = react_utilities_1.useMergedRefs(state.input.ref);
  state.input.ref = inputRef; // Set the <input> element's checked and indeterminate properties based on our tri-state property.
  // Since indeterminate can only be set via javascript, it has to be done in a layout effect.

  react_utilities_1.useIsomorphicLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = mixed;
    }
  }, [inputRef, mixed]);
  return state;
};

exports.useCheckbox_unstable = useCheckbox_unstable;
//# sourceMappingURL=useCheckbox.js.map