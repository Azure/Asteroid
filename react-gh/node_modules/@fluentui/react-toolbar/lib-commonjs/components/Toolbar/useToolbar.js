"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToolbar_unstable = void 0;

const react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_utilities_2 = /*#__PURE__*/require("@fluentui/react-utilities");

const react_tabster_1 = /*#__PURE__*/require("@fluentui/react-tabster");
/**
 * Create the state required to render Toolbar.
 *
 * The returned state can be modified with hooks such as useToolbarStyles_unstable,
 * before being passed to renderToolbar_unstable.
 *
 * @param props - props from this instance of Toolbar
 * @param ref - reference to root HTMLElement of Toolbar
 */


const useToolbar_unstable = (props, ref) => {
  const {
    size = 'medium',
    vertical = false
  } = props;
  const arrowNavigationProps = react_tabster_1.useArrowNavigationGroup({
    circular: true,
    axis: 'both'
  });
  const initialState = {
    size,
    vertical,
    // TODO add appropriate props/defaults
    components: {
      // TODO add each slot's element type or component
      root: 'div'
    },
    // TODO add appropriate slots, for example:
    // mySlot: resolveShorthand(props.mySlot),
    root: react_utilities_2.getNativeElementProps('div', {
      role: 'toolbar',
      ref,
      ...arrowNavigationProps,
      ...props
    })
  };
  const [checkedValues, onCheckedValueChange] = useToolbarSelectableState({
    checkedValues: props.checkedValues,
    defaultCheckedValues: props.defaultCheckedValues,
    onCheckedValueChange: props.onCheckedValueChange
  });
  const handleToggleButton = react_utilities_1.useEventCallback((e, name, value, checked) => {
    if (name && value) {
      const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
      const newCheckedItems = [...checkedItems];

      if (checked) {
        newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
      } else {
        newCheckedItems.push(value);
      }

      onCheckedValueChange === null || onCheckedValueChange === void 0 ? void 0 : onCheckedValueChange(e, {
        name,
        checkedItems: newCheckedItems
      });
    }
  });
  const handleRadio = react_utilities_1.useEventCallback((e, name, value, checked) => {
    if (name && value) {
      onCheckedValueChange === null || onCheckedValueChange === void 0 ? void 0 : onCheckedValueChange(e, {
        name,
        checkedItems: [value]
      });
    }
  });
  return { ...initialState,
    handleToggleButton,
    handleRadio,
    checkedValues: checkedValues !== null && checkedValues !== void 0 ? checkedValues : {}
  };
};

exports.useToolbar_unstable = useToolbar_unstable;
/**
 * Adds appropriate state values and handlers for selectable items
 * i.e checkboxes and radios
 */

const useToolbarSelectableState = state => {
  const [checkedValues, setCheckedValues] = react_utilities_1.useControllableState({
    state: state.checkedValues,
    defaultState: state.defaultCheckedValues,
    initialState: {}
  });
  const {
    onCheckedValueChange: onCheckedValueChangeOriginal
  } = state;
  const onCheckedValueChange = react_utilities_1.useEventCallback((e, {
    name,
    checkedItems
  }) => {
    if (onCheckedValueChangeOriginal) {
      onCheckedValueChangeOriginal(e, {
        name,
        checkedItems
      });
    }

    setCheckedValues(s => {
      return s ? { ...s,
        [name]: checkedItems
      } : {
        [name]: checkedItems
      };
    });
  });
  return [checkedValues, onCheckedValueChange];
};
//# sourceMappingURL=useToolbar.js.map