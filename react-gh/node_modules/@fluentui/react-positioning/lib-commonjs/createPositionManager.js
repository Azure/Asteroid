"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPositionManager = void 0;

const dom_1 = /*#__PURE__*/require("@floating-ui/dom");

const utils_1 = /*#__PURE__*/require("./utils");
/**
 * @internal
 * @returns manager that handles positioning out of the react lifecycle
 */


function createPositionManager(options) {
  const {
    container,
    target,
    arrow,
    strategy,
    middleware,
    placement
  } = options;

  if (!target || !container) {
    return {
      updatePosition: () => undefined,
      dispose: () => undefined
    };
  }

  let isFirstUpdate = true;
  const scrollParents = new Set();
  const targetWindow = container.ownerDocument.defaultView; // When the container is first resolved, set position `fixed` to avoid scroll jumps.
  // Without this scroll jumps can occur when the element is rendered initially and receives focus

  Object.assign(container.style, {
    position: 'fixed',
    left: 0,
    top: 0,
    margin: 0
  });

  const forceUpdate = () => {
    if (isFirstUpdate) {
      scrollParents.add(utils_1.getScrollParent(container));

      if (target instanceof HTMLElement) {
        scrollParents.add(utils_1.getScrollParent(target));
      }

      scrollParents.forEach(scrollParent => {
        scrollParent.addEventListener('scroll', updatePosition);
      });
      isFirstUpdate = false;
    }

    Object.assign(container.style, {
      position: strategy
    });
    dom_1.computePosition(target, container, {
      placement,
      middleware,
      strategy
    }).then(({
      x,
      y,
      middlewareData,
      placement: computedPlacement
    }) => {
      utils_1.writeArrowUpdates({
        arrow,
        middlewareData
      });
      utils_1.writeContainerUpdates({
        container,
        middlewareData,
        placement: computedPlacement,
        coordinates: {
          x,
          y
        },
        lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
        strategy
      });
    }).catch(err => {
      // https://github.com/floating-ui/floating-ui/issues/1845
      // FIXME for node > 14
      // node 15 introduces promise rejection which means that any components
      // tests need to be `it('', async () => {})` otherwise there can be race conditions with
      // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist
      // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing
      // will actually be counter productive
      if (process.env.NODE_ENV === 'development') {
        // eslint-disable-next-line no-console
        console.error('[usePositioning]: Failed to calculate position', err);
      }
    });
  };

  const updatePosition = utils_1.debounce(() => forceUpdate());

  const dispose = () => {
    if (targetWindow) {
      targetWindow.removeEventListener('scroll', updatePosition);
      targetWindow.removeEventListener('resize', updatePosition);
    }

    scrollParents.forEach(scrollParent => {
      scrollParent.removeEventListener('scroll', updatePosition);
    });
  };

  if (targetWindow) {
    targetWindow.addEventListener('scroll', updatePosition);
    targetWindow.addEventListener('resize', updatePosition);
  } // Update the position on initialization


  updatePosition();
  return {
    updatePosition,
    dispose
  };
}

exports.createPositionManager = createPositionManager;
//# sourceMappingURL=createPositionManager.js.map