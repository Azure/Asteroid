define(["require", "exports", "tslib", "@floating-ui/dom", "@fluentui/react-shared-contexts", "@fluentui/react-utilities", "react", "./utils", "./middleware", "./createPositionManager"], function (require, exports, tslib_1, dom_1, react_shared_contexts_1, react_utilities_1, React, utils_1, middleware_1, createPositionManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.usePositioning = void 0;
    /**
     * @internal
     */
    function usePositioning(options) {
        var managerRef = React.useRef(null);
        var targetRef = React.useRef(null);
        var overrideTargetRef = React.useRef(null);
        var containerRef = React.useRef(null);
        var arrowRef = React.useRef(null);
        var _a = options.enabled, enabled = _a === void 0 ? true : _a;
        var resolvePositioningOptions = usePositioningOptions(options);
        var updatePositionManager = React.useCallback(function () {
            var _a;
            if (managerRef.current) {
                managerRef.current.dispose();
            }
            managerRef.current = null;
            var target = (_a = overrideTargetRef.current) !== null && _a !== void 0 ? _a : targetRef.current;
            if (enabled && react_utilities_1.canUseDOM() && target && containerRef.current) {
                managerRef.current = createPositionManager_1.createPositionManager(tslib_1.__assign({ container: containerRef.current, target: target, arrow: arrowRef.current }, resolvePositioningOptions(containerRef.current, arrowRef.current)));
            }
        }, [enabled, resolvePositioningOptions]);
        var setOverrideTarget = React.useCallback(function (target) {
            overrideTargetRef.current = target;
            updatePositionManager();
        }, [updatePositionManager]);
        React.useImperativeHandle(options.positioningRef, function () { return ({
            updatePosition: function () { var _a; return (_a = managerRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition(); },
            setTarget: function (target) {
                if (options.target && process.env.NODE_ENV !== 'production') {
                    var err = new Error();
                    // eslint-disable-next-line no-console
                    console.warn('Imperative setTarget should not be used at the same time as target option');
                    // eslint-disable-next-line no-console
                    console.warn(err.stack);
                }
                setOverrideTarget(target);
            },
        }); }, [options.target, setOverrideTarget]);
        react_utilities_1.useIsomorphicLayoutEffect(function () {
            var _a;
            setOverrideTarget((_a = options.target) !== null && _a !== void 0 ? _a : null);
        }, [options.target, setOverrideTarget]);
        react_utilities_1.useIsomorphicLayoutEffect(function () {
            updatePositionManager();
        }, [updatePositionManager]);
        if (process.env.NODE_ENV !== 'production') {
            // This checked should run only in development mode
            // eslint-disable-next-line react-hooks/rules-of-hooks
            React.useEffect(function () {
                var _a;
                if (containerRef.current) {
                    var contentNode = containerRef.current;
                    var treeWalker = (_a = contentNode.ownerDocument) === null || _a === void 0 ? void 0 : _a.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, {
                        acceptNode: utils_1.hasAutofocusFilter,
                    });
                    while (treeWalker.nextNode()) {
                        var node = treeWalker.currentNode;
                        // eslint-disable-next-line no-console
                        console.warn('<Popper>:', node);
                        // eslint-disable-next-line no-console
                        console.warn([
                            '<Popper>: ^ this node contains "autoFocus" prop on a React element. This can break the initial',
                            'positioning of an element and cause a window jump effect. This issue occurs because React polyfills',
                            '"autoFocus" behavior to solve inconsistencies between different browsers:',
                            'https://github.com/facebook/react/issues/11851#issuecomment-351787078',
                            '\n',
                            'However, ".focus()" in this case occurs before any other React effects will be executed',
                            '(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really',
                            'want to use "autoFocus" please add "position: fixed" to styles of the element that is wrapped by',
                            '"Popper".',
                            "In general, it's not recommended to use \"autoFocus\" as it may break accessibility aspects:",
                            'https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md',
                            '\n',
                            'We suggest to use the "trapFocus" prop on Fluent components or a catch "ref" and then use',
                            '"ref.current.focus" in React.useEffect():',
                            'https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element',
                        ].join(' '));
                    }
                }
                // We run this check once, no need to add deps here
                // TODO: Should be rework to handle options.enabled and contentRef updates
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, []);
        }
        var setTarget = utils_1.useCallbackRef(null, function (target) {
            if (targetRef.current !== target) {
                targetRef.current = target;
                updatePositionManager();
            }
        });
        var setContainer = utils_1.useCallbackRef(null, function (container) {
            if (containerRef.current !== container) {
                containerRef.current = container;
                updatePositionManager();
            }
        });
        var setArrow = utils_1.useCallbackRef(null, function (arrow) {
            if (arrowRef.current !== arrow) {
                arrowRef.current = arrow;
                updatePositionManager();
            }
        });
        // Let users use callback refs so they feel like 'normal' DOM refs
        return { targetRef: setTarget, containerRef: setContainer, arrowRef: setArrow };
    }
    exports.usePositioning = usePositioning;
    function usePositioningOptions(options) {
        var align = options.align, arrowPadding = options.arrowPadding, autoSize = options.autoSize, coverTarget = options.coverTarget, flipBoundary = options.flipBoundary, offset = options.offset, overflowBoundary = options.overflowBoundary, pinned = options.pinned, position = options.position, disableTether = options.unstable_disableTether, positionFixed = options.positionFixed;
        var dir = react_shared_contexts_1.useFluent_unstable().dir;
        var isRtl = dir === 'rtl';
        var strategy = positionFixed ? 'fixed' : 'absolute';
        return React.useCallback(function (container, arrow) {
            var hasScrollableElement = utils_1.hasScrollParent(container);
            var placement = utils_1.toFloatingUIPlacement(align, position, isRtl);
            var middleware = [
                offset && middleware_1.offset(offset),
                coverTarget && middleware_1.coverTarget(),
                !pinned && middleware_1.flip({ container: container, flipBoundary: flipBoundary, hasScrollableElement: hasScrollableElement }),
                middleware_1.shift({ container: container, hasScrollableElement: hasScrollableElement, overflowBoundary: overflowBoundary, disableTether: disableTether }),
                autoSize && middleware_1.maxSize(autoSize),
                middleware_1.intersecting(),
                arrow && dom_1.arrow({ element: arrow, padding: arrowPadding }),
                dom_1.hide({ strategy: 'referenceHidden' }),
                dom_1.hide({ strategy: 'escaped' }),
            ].filter(Boolean);
            return {
                placement: placement,
                middleware: middleware,
                strategy: strategy,
            };
        }, [
            align,
            arrowPadding,
            autoSize,
            coverTarget,
            disableTether,
            flipBoundary,
            isRtl,
            offset,
            overflowBoundary,
            pinned,
            position,
            strategy,
        ]);
    }
});
//# sourceMappingURL=usePositioning.js.map