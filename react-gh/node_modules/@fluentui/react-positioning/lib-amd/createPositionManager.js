define(["require", "exports", "@floating-ui/dom", "./utils"], function (require, exports, dom_1, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPositionManager = void 0;
    /**
     * @internal
     * @returns manager that handles positioning out of the react lifecycle
     */
    function createPositionManager(options) {
        var container = options.container, target = options.target, arrow = options.arrow, strategy = options.strategy, middleware = options.middleware, placement = options.placement;
        if (!target || !container) {
            return {
                updatePosition: function () { return undefined; },
                dispose: function () { return undefined; },
            };
        }
        var isFirstUpdate = true;
        var scrollParents = new Set();
        var targetWindow = container.ownerDocument.defaultView;
        // When the container is first resolved, set position `fixed` to avoid scroll jumps.
        // Without this scroll jumps can occur when the element is rendered initially and receives focus
        Object.assign(container.style, { position: 'fixed', left: 0, top: 0, margin: 0 });
        var forceUpdate = function () {
            if (isFirstUpdate) {
                scrollParents.add(utils_1.getScrollParent(container));
                if (target instanceof HTMLElement) {
                    scrollParents.add(utils_1.getScrollParent(target));
                }
                scrollParents.forEach(function (scrollParent) {
                    scrollParent.addEventListener('scroll', updatePosition);
                });
                isFirstUpdate = false;
            }
            Object.assign(container.style, { position: strategy });
            dom_1.computePosition(target, container, { placement: placement, middleware: middleware, strategy: strategy })
                .then(function (_a) {
                var x = _a.x, y = _a.y, middlewareData = _a.middlewareData, computedPlacement = _a.placement;
                utils_1.writeArrowUpdates({ arrow: arrow, middlewareData: middlewareData });
                utils_1.writeContainerUpdates({
                    container: container,
                    middlewareData: middlewareData,
                    placement: computedPlacement,
                    coordinates: { x: x, y: y },
                    lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
                    strategy: strategy,
                });
            })
                .catch(function (err) {
                // https://github.com/floating-ui/floating-ui/issues/1845
                // FIXME for node > 14
                // node 15 introduces promise rejection which means that any components
                // tests need to be `it('', async () => {})` otherwise there can be race conditions with
                // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist
                // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing
                // will actually be counter productive
                if (process.env.NODE_ENV === 'development') {
                    // eslint-disable-next-line no-console
                    console.error('[usePositioning]: Failed to calculate position', err);
                }
            });
        };
        var updatePosition = utils_1.debounce(function () { return forceUpdate(); });
        var dispose = function () {
            if (targetWindow) {
                targetWindow.removeEventListener('scroll', updatePosition);
                targetWindow.removeEventListener('resize', updatePosition);
            }
            scrollParents.forEach(function (scrollParent) {
                scrollParent.removeEventListener('scroll', updatePosition);
            });
        };
        if (targetWindow) {
            targetWindow.addEventListener('scroll', updatePosition);
            targetWindow.addEventListener('resize', updatePosition);
        }
        // Update the position on initialization
        updatePosition();
        return {
            updatePosition: updatePosition,
            dispose: dispose,
        };
    }
    exports.createPositionManager = createPositionManager;
});
//# sourceMappingURL=createPositionManager.js.map