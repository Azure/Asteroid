define(["require", "exports", "tslib", "@fluentui/keyboard-keys", "@fluentui/react-utilities"], function (require, exports, tslib_1, keyboard_keys_1, react_utilities_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useARIAButtonProps = void 0;
    /**
     * @internal
     *
     * Button keyboard handling, role, disabled and tabIndex implementation that ensures ARIA spec
     * for multiple scenarios of non native button elements. Ensuring 1st rule of ARIA for cases
     * where no attribute addition is required.
     *
     * @param type - the proper scenario to be interpreted by the hook.
     *  1. `button` - Minimal interference from the hook, as semantic button already supports most of the states
     *  2. `a` or `div` - Proper keyboard/mouse handling plus other support to ensure ARIA behavior
     * @param props - the props to be passed down the line to the desired element.
     * This hook will encapsulate proper properties, such as `onClick`, `onKeyDown`, `onKeyUp`, etc,.
     *
     * @example
     * ```tsx
     * const buttonProps = useARIAButtonProps('a', {
     *   href: './some-route'
     *   onClick: () => console.log('this should run both on click and Space and Enter')
     * })
     *
     * // ...
     *
     * return (
     *  <a {...buttonProps}>This anchor will behave as a proper button</a>
     * )
     * ```
     */
    function useARIAButtonProps(type, props) {
        var _a = props !== null && props !== void 0 ? props : {}, disabled = _a.disabled, _b = _a.disabledFocusable, disabledFocusable = _b === void 0 ? false : _b, ariaDisabled = _a["aria-disabled"], onClick = _a.onClick, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, rest = tslib_1.__rest(_a, ["disabled", "disabledFocusable", 'aria-disabled', "onClick", "onKeyDown", "onKeyUp"]);
        var normalizedARIADisabled = typeof ariaDisabled === 'string' ? ariaDisabled === 'true' : ariaDisabled;
        var isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
        var handleClick = react_utilities_1.useEventCallback(function (ev) {
            if (isDisabled) {
                ev.preventDefault();
                ev.stopPropagation();
            }
            else {
                onClick === null || onClick === void 0 ? void 0 : onClick(ev);
            }
        });
        var handleKeyDown = react_utilities_1.useEventCallback(function (ev) {
            onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
            if (ev.isDefaultPrevented()) {
                return;
            }
            var key = ev.key;
            if (isDisabled && (key === keyboard_keys_1.Enter || key === keyboard_keys_1.Space)) {
                ev.preventDefault();
                ev.stopPropagation();
                return;
            }
            if (key === keyboard_keys_1.Space) {
                ev.preventDefault();
                return;
            }
            // If enter is pressed, activate the button
            else if (key === keyboard_keys_1.Enter) {
                ev.preventDefault();
                ev.currentTarget.click();
            }
        });
        var handleKeyUp = react_utilities_1.useEventCallback(function (ev) {
            onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
            if (ev.isDefaultPrevented()) {
                return;
            }
            var key = ev.key;
            if (isDisabled && (key === keyboard_keys_1.Enter || key === keyboard_keys_1.Space)) {
                ev.preventDefault();
                ev.stopPropagation();
                return;
            }
            if (key === keyboard_keys_1.Space) {
                ev.preventDefault();
                ev.currentTarget.click();
            }
        });
        // If a <button> tag is to be rendered we just need to set disabled and aria-disabled correctly
        if (type === 'button' || type === undefined) {
            return tslib_1.__assign(tslib_1.__assign({}, rest), { disabled: disabled && !disabledFocusable, 'aria-disabled': disabledFocusable ? true : normalizedARIADisabled, 
                // onclick should still use internal handler to ensure prevention if disabled
                // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
                onClick: disabledFocusable ? undefined : handleClick, onKeyUp: disabledFocusable ? undefined : onKeyUp, onKeyDown: disabledFocusable ? undefined : onKeyDown });
        }
        // If an <a> or <div> tag is to be rendered we have to remove disabled and type,
        // and set aria-disabled, role and tabIndex.
        else {
            var resultProps = tslib_1.__assign(tslib_1.__assign({ role: 'button', tabIndex: disabled && !disabledFocusable ? undefined : 0 }, rest), { 
                // If it's not a <button> than listeners are required even with disabledFocusable
                // Since you cannot assure the default behavior of the element
                // E.g: <a> will redirect on click
                onClick: handleClick, onKeyUp: handleKeyUp, onKeyDown: handleKeyDown, 'aria-disabled': disabled || disabledFocusable || normalizedARIADisabled });
            if (type === 'a' && isDisabled) {
                resultProps.href = undefined;
            }
            return resultProps;
        }
    }
    exports.useARIAButtonProps = useARIAButtonProps;
});
//# sourceMappingURL=useARIAButtonProps.js.map