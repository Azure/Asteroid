import * as React from 'react';
import { Enter, Space } from '@fluentui/keyboard-keys';
import { mergeCallbacks, resolveShorthand } from '@fluentui/react-utilities';
import { useFocusFinders } from '@fluentui/react-tabster';
/**
 * @internal
 *
 * Create the state related to selectable cards.
 *
 * This internal hook controls all the logic for selectable cards and is
 * intended to be used alongside with useCard_unstable.
 *
 * @param props - props from this instance of Card
 * @param a11yProps - accessibility props shared between elements of the card
 * @param ref - reference to the root element of Card
 */

export const useCardSelectable = (props, {
  referenceLabel,
  referenceId
}, cardRef) => {
  const {
    checkbox = {},
    selected,
    defaultSelected,
    onSelectionChange,
    floatingAction,
    onClick,
    onKeyDown
  } = props;
  const {
    findAllFocusable
  } = useFocusFinders();
  const checkboxRef = React.useRef(null);
  const isSelectable = [selected, defaultSelected, onSelectionChange].some(prop => typeof prop !== 'undefined');
  const [isCardSelected, setIsCardSelected] = React.useState(false);
  const [isSelectFocused, setIsSelectFocused] = React.useState(false);
  const shouldRestrictTriggerAction = React.useCallback(event => {
    if (!cardRef.current) {
      return false;
    }

    const focusableElements = findAllFocusable(cardRef.current);
    const target = event.target;
    const isElementInFocusableGroup = focusableElements.some(element => element.contains(target));
    const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
    return isElementInFocusableGroup && !isCheckboxSlot;
  }, [cardRef, findAllFocusable]);
  const onChangeHandler = React.useCallback(event => {
    if (shouldRestrictTriggerAction(event)) {
      return;
    }

    const newCheckedValue = !isCardSelected;
    setIsCardSelected(newCheckedValue);

    if (onSelectionChange) {
      onSelectionChange(event, {
        selected: newCheckedValue
      });
    }
  }, [onSelectionChange, isCardSelected, shouldRestrictTriggerAction]);
  const onKeyDownHandler = React.useCallback(event => {
    if ([Enter, Space].includes(event.key)) {
      event.preventDefault();
      onChangeHandler(event);
    }
  }, [onChangeHandler]);
  const checkboxSlot = React.useMemo(() => {
    if (!isSelectable || !!floatingAction) {
      return;
    }

    const selectableCheckboxProps = {};

    if (referenceId) {
      selectableCheckboxProps['aria-labelledby'] = referenceId;
    } else if (referenceLabel) {
      selectableCheckboxProps['aria-label'] = referenceLabel;
    }

    return resolveShorthand(checkbox, {
      defaultProps: {
        ref: checkboxRef,
        type: 'checkbox',
        checked: isCardSelected,
        onChange: event => onChangeHandler(event),
        onFocus: () => setIsSelectFocused(true),
        onBlur: () => setIsSelectFocused(false),
        ...selectableCheckboxProps
      }
    });
  }, [isSelectable, floatingAction, referenceId, referenceLabel, checkbox, isCardSelected, onChangeHandler]);
  const selectableCardProps = React.useMemo(() => {
    if (!isSelectable) {
      return null;
    }

    return {
      onClick: mergeCallbacks(onClick, onChangeHandler),
      onKeyDown: mergeCallbacks(onKeyDown, onKeyDownHandler)
    };
  }, [isSelectable, onChangeHandler, onClick, onKeyDown, onKeyDownHandler]);
  React.useEffect(() => setIsCardSelected(Boolean(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : selected)), [defaultSelected, selected, setIsCardSelected]);
  return {
    selected: isCardSelected,
    selectable: isSelectable,
    selectFocused: isSelectFocused,
    selectableCardProps,
    checkboxSlot
  };
};
//# sourceMappingURL=useCardSelectable.js.map