define(["require", "exports", "tslib", "react", "@fluentui/react-positioning", "@fluentui/react-shared-contexts", "@fluentui/react-utilities", "./private/constants", "@fluentui/keyboard-keys"], function (require, exports, tslib_1, React, react_positioning_1, react_shared_contexts_1, react_utilities_1, constants_1, keyboard_keys_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTooltip_unstable = void 0;
    /**
     * Create the state required to render Tooltip.
     *
     * The returned state can be modified with hooks such as useTooltipStyles_unstable,
     * before being passed to renderTooltip_unstable.
     *
     * @param props - props from this instance of Tooltip
     */
    var useTooltip_unstable = function (props) {
        var _a, _b, _c, _d;
        var context = react_shared_contexts_1.useTooltipVisibility_unstable();
        var isServerSideRender = react_utilities_1.useIsSSR();
        var targetDocument = react_shared_contexts_1.useFluent_unstable().targetDocument;
        var _e = react_utilities_1.useTimeout(), setDelayTimeout = _e[0], clearDelayTimeout = _e[1];
        var _f = props.appearance, appearance = _f === void 0 ? 'normal' : _f, children = props.children, content = props.content, _g = props.withArrow, withArrow = _g === void 0 ? false : _g, _h = props.positioning, positioning = _h === void 0 ? 'above' : _h, onVisibleChange = props.onVisibleChange, relationship = props.relationship, _j = props.showDelay, showDelay = _j === void 0 ? 250 : _j, _k = props.hideDelay, hideDelay = _k === void 0 ? 250 : _k, mountNode = props.mountNode;
        var _l = react_utilities_1.useControllableState({ state: props.visible, initialState: false }), visible = _l[0], setVisibleInternal = _l[1];
        var setVisible = React.useCallback(function (newVisible, ev) {
            clearDelayTimeout();
            setVisibleInternal(function (oldVisible) {
                if (newVisible !== oldVisible) {
                    onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, { visible: newVisible });
                }
                return newVisible;
            });
        }, [clearDelayTimeout, setVisibleInternal, onVisibleChange]);
        var state = {
            withArrow: withArrow,
            positioning: positioning,
            showDelay: showDelay,
            hideDelay: hideDelay,
            relationship: relationship,
            visible: visible,
            shouldRenderTooltip: visible,
            appearance: appearance,
            mountNode: mountNode,
            // Slots
            components: {
                content: 'div',
            },
            content: react_utilities_1.resolveShorthand(content, {
                defaultProps: {
                    role: 'tooltip',
                },
                required: true,
            }),
        };
        state.content.id = react_utilities_1.useId('tooltip-', state.content.id);
        var positioningOptions = tslib_1.__assign({ enabled: state.visible, arrowPadding: 2 * constants_1.tooltipBorderRadius, position: 'above', align: 'center', offset: 4 }, react_positioning_1.resolvePositioningShorthand(state.positioning));
        if (state.withArrow) {
            positioningOptions.offset = react_positioning_1.mergeArrowOffset(positioningOptions.offset, constants_1.arrowHeight);
        }
        var _m = react_positioning_1.usePositioning(positioningOptions), targetRef = _m.targetRef, containerRef = _m.containerRef, arrowRef = _m.arrowRef;
        state.content.ref = react_utilities_1.useMergedRefs(state.content.ref, containerRef);
        state.arrowRef = arrowRef;
        // When this tooltip is visible, hide any other tooltips, and register it
        // as the visibleTooltip with the TooltipContext.
        // Also add a listener on document to hide the tooltip if Escape is pressed
        react_utilities_1.useIsomorphicLayoutEffect(function () {
            var _a;
            if (visible) {
                var thisTooltip_1 = { hide: function () { return setVisible(false); } };
                (_a = context.visibleTooltip) === null || _a === void 0 ? void 0 : _a.hide();
                context.visibleTooltip = thisTooltip_1;
                var onDocumentKeyDown_1 = function (ev) {
                    if (ev.key === keyboard_keys_1.Escape) {
                        thisTooltip_1.hide();
                        // stop propagation to avoid conflicting with other elements that listen for `Escape`
                        // e,g: Dialog, Popover, Menu
                        ev.stopPropagation();
                    }
                };
                targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('keydown', onDocumentKeyDown_1, {
                    // As this event is added at targeted document,
                    // we need to capture the event to be sure keydown handling from tooltip happens first
                    capture: true,
                });
                return function () {
                    if (context.visibleTooltip === thisTooltip_1) {
                        context.visibleTooltip = undefined;
                    }
                    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('keydown', onDocumentKeyDown_1, { capture: true });
                };
            }
        }, [context, targetDocument, visible, setVisible]);
        // The focused element gets a blur event when the document loses focus
        // (e.g. switching tabs in the browser), but we don't want to show the
        // tooltip again when the document gets focus back. Handle this case by
        // checking if the blurred element is still the document's activeElement.
        // See https://github.com/microsoft/fluentui/issues/13541
        var ignoreNextFocusEventRef = React.useRef(false);
        // Listener for onPointerEnter and onFocus on the trigger element
        var onEnterTrigger = React.useCallback(function (ev) {
            if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {
                ignoreNextFocusEventRef.current = false;
                return;
            }
            // Show immediately if another tooltip is already visible
            var delay = context.visibleTooltip ? 0 : state.showDelay;
            setDelayTimeout(function () {
                setVisible(true, ev);
            }, delay);
            ev.persist(); // Persist the event since the setVisible call will happen asynchronously
        }, [setDelayTimeout, setVisible, state.showDelay, context]);
        // Listener for onPointerLeave and onBlur on the trigger element
        var onLeaveTrigger = React.useCallback(function (ev) {
            var delay = state.hideDelay;
            if (ev.type === 'blur') {
                // Hide immediately when losing focus
                delay = 0;
                ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
            }
            setDelayTimeout(function () {
                setVisible(false, ev);
            }, delay);
            ev.persist(); // Persist the event since the setVisible call will happen asynchronously
        }, [setDelayTimeout, setVisible, state.hideDelay, targetDocument]);
        // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.
        // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.
        state.content.onPointerEnter = react_utilities_1.mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
        state.content.onPointerLeave = react_utilities_1.mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
        state.content.onFocus = react_utilities_1.mergeCallbacks(state.content.onFocus, clearDelayTimeout);
        state.content.onBlur = react_utilities_1.mergeCallbacks(state.content.onBlur, onLeaveTrigger);
        var child = react_utilities_1.getTriggerChild(children);
        var triggerAriaProps = {};
        if (relationship === 'label') {
            // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.
            if (typeof state.content.children === 'string') {
                triggerAriaProps['aria-label'] = state.content.children;
            }
            else {
                triggerAriaProps['aria-labelledby'] = state.content.id;
                // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element
                state.shouldRenderTooltip = true;
            }
        }
        else if (relationship === 'description') {
            triggerAriaProps['aria-describedby'] = state.content.id;
            // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element
            state.shouldRenderTooltip = true;
        }
        // Don't render the Tooltip in SSR to avoid hydration errors
        if (isServerSideRender) {
            state.shouldRenderTooltip = false;
        }
        var childTargetRef = react_utilities_1.useMergedRefs(child === null || child === void 0 ? void 0 : child.ref, targetRef);
        // Apply the trigger props to the child, either by calling the render function, or cloning with the new props
        state.children = react_utilities_1.applyTriggerPropsToChildren(children, tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, triggerAriaProps), child === null || child === void 0 ? void 0 : child.props), { 
            // If the target prop is not provided, attach targetRef to the trigger element's ref prop
            ref: positioningOptions.target === undefined ? childTargetRef : child === null || child === void 0 ? void 0 : child.ref, onPointerEnter: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks((_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.onPointerEnter, onEnterTrigger)), onPointerLeave: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks((_b = child === null || child === void 0 ? void 0 : child.props) === null || _b === void 0 ? void 0 : _b.onPointerLeave, onLeaveTrigger)), onFocus: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks((_c = child === null || child === void 0 ? void 0 : child.props) === null || _c === void 0 ? void 0 : _c.onFocus, onEnterTrigger)), onBlur: react_utilities_1.useEventCallback(react_utilities_1.mergeCallbacks((_d = child === null || child === void 0 ? void 0 : child.props) === null || _d === void 0 ? void 0 : _d.onBlur, onLeaveTrigger)) }));
        return state;
    };
    exports.useTooltip_unstable = useTooltip_unstable;
});
//# sourceMappingURL=useTooltip.js.map